--------------------------------------------------------------------------------
--AI Code
--------------------------------------------------------------------------------
--The AI is designed to predict the performance of a player based on a combination
--the current scores, the value of uncalculated points (ie. incomplete features),
--and various penalties (ie. stuck followers). This "score" is calculated at the beginning of the turn
--with AICalculateBaselineScores. The AI then simulates the placement of a tile and/or
--figure at all possible locations, and calculates the difference between the two as
--the "score" of that move
--------------------------------------------------------------------------------

--COSMETIC CONSTS
AI_DRAW_TILE_TIME = 1.0 --time delay to allow the drawn tile to travel to the AI player's hand
AI_ANIMATIONS_ENABLED = false --will move pieces smoothly if true, otherwise the pieces will instantly move
AI_DRAW_TILE_TO_HAND = false -- will move the pieces to the AI player's hand first. If false, pieces will be moved in front of their hand instead
AI_TAUNT_THRESHOLD = 20 -- a move that nets a gain of more than this many points will prompt the AI to taunt the opponents

--SHARED CONSTS
END_GAME_TRANSITION = 20 --when there are less than this number of tiles (per player), the AI will begin abandoning difficult to complete roads with inns and cities with cathedrals.
SCORE_THREAT_THRESHOLD = 50 --players that are more than this many points behind are no longer considered a threat and won't be factored into the decisions
FOLLOWER_SCORE_THRESHOLD = 0.75 --player won't use a figure to take a feature unless it is worth at least this much
USED_FOLLOWER_PENALTY_HARD = 0.50 --each follower that a player doesn't have in their supply will make it more picky of when to use a follower by this many points
USED_LAST_FOLLOWER_PENALTY = 20.0 --penalty instead of the above. Using the last follower should be strictly discouraged unless there is a large enough benefit
UNFINISHED_TRADE_TOKEN_VALUE = 1.0 --Extra value provided by having a trade token in your city (although it isn't actually worth anything, encouraging yourself and/or your opponents to finish the city could be seen as a benefit)
SHEPHERD_EXTEND_VALUE = 1.5 --Extra value provided by adding to a feature with a shepherd
SHEPHERD_DRAW_TOKEN_THRESHOLD = 0.0 --An extra token will be drawn if the calculated value is worth more than this. Otherwise, the flock will be scored.
BUILDER_EXTRA_TURN_VALUE = 1.0 --Extra value provided by adding to a feature with a builder

--HARD MODE CONSTS
NUMBER_OF_DRAWN_TILES_FOR_BLOCK_PERCENTAGE = 10 --calculate the odds that this tile position will be blocked for this many drawn tiles
BLOCK_PERCENTAGE_POWER_MODIFIER = 2 --take the block percentage to the power of this number, and multiply it by the score to get the adjusted score
STUCK_FOLLOWER_PENALTY = 0.3 --this penalty will be applied to each follower that is 100% stuck until the end of the game (including farmers). The penalty is multiplied by the number of tiles left. This penalty is also partially applied to followers that have a chance ot get stuck.
STUCK_BIG_FOLLOWER_PENALTY = 0.45 --this penalty will be applied to each big follower that is 100% stuck until the end of the game (including farmers). The penalty is multiplied by the number of tiles left. This penalty is also partially applied to followers that have a chance ot get stuck.
STUCK_BUILDER_PENALTY = 0.3 --this penalty will be applied to a builder that is 100% stuck until the end of the game. The penalty is multiplied by the number of tiles left. This penalty is also partially applied to builders that have a chance ot get stuck.
STUCK_SHEPHERD_PENALTY = 0.3 --this penalty will be applied to a shepherd that is 100% stuck until the end of the game. The penalty is multiplied by the number of tiles left. This penalty is also partially applied to builders that have a chance ot get stuck.
STUCK_PIG_PENALTY = 0.1 --this penalty will be applied to a pig multiplied by the number of tiles left. This is intended to discourage the pig from being used too early. Similar to the farmer, the pig is always 100% "stuck"
BUILDER_PLACEMENT_BONUS_VALUE = 0.5 --Extra value for having a feature with a builder (this is needed to give incentive for the AI to place it, since the stuck penalty will make it highly unfavored)
MAX_JOIN_PERCENTAGE = 0.8 --connections with very high join percentages tend to screw up the AI's decisions since it will already get 99% of the score benefit from a connection that hasn't even been made. Therefore, use this limit so that there is incentive to finish the connection.

--EASY MODE CONSTS
OPEN_FEATURE_PENALTY = 0.30 --score penalty to apply for each open end of this feature, to provide incentive for easier features to complete
FIELD_PENALTY = 2.5 --score penalty to apply to the field, to prevent it being used too early in the game
USED_FOLLOWER_PENALTY_EASY = 0.45 --each follower that a player doesn't have in their supply will make it more picky of when to use a follower by this many points

function AIStateHandler()
    --debugMessage(1, "AIStateHandler - " .. turnState)
    if turnState == 'awaiting tile placement' then
        if (controlPanelSettings['StartingTileRiverII'] or controlPanelSettings['StartingTileRiver'] or controlPanelSettings['StartingTileRiverBB5']) and hasFinishedRiver() then
            -- local itemRemoved = false
            -- for _, obj_GUID in pairs({forkTile_GUID, riverBodyTiles_GUID, finalRiverTile_GUID, springTile_GUID, lakeTile_GUID}) do
            --     if obj_GUID ~= nil then
            --         local obj = getObjectFromGUID(obj_GUID)
            --         if obj ~= nil then
            --             itemRemoved = true
            --             obj.destruct()
            --         end
            --     end
            -- end
            -- if itemRemoved then
            --     gameNotification("River is already finished. Removing additional tiles.", NEUTRAL_COLOR, activePlayers[currentPlayer])
            -- end
            forkTile_GUID = nil
            riverBodyTiles_GUID = nil
            finalRiverTile_GUID = nil
            springTile_GUID = nil
            lakeTile_GUID = nil
            -- local tileStack = getObjectFromGUID(tileStack_GUID)
            -- if tileStack ~= nil then
            --     tileStack.setLock(false)
            --     tileStack.interactable = true
            -- end
        end
        gameNotification({"MESSAGE_AI_CALCULATING"}, NEUTRAL_COLOR, activePlayers[currentPlayer])
        startLuaCoroutine(self, 'AIChooseTileLocation')
    elseif turnState == 'place gold on tile' then
        gameNotification("AI not implemented for expansion: The Goldmines", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return addGoldToTile(lastPlacedTileX, lastPlacedTileZ)
    elseif turnState == 'awaiting gold placement' then
        gameNotification("AI not implemented for expansion: The Goldmines", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return displayGoldButtons()
    elseif turnState == 'awaiting figure decision' then
        if highestScorePos == nil then
            gameNotification({"MESSAGE_AI_SKIPPING_FIGURE"}, NEUTRAL_COLOR, activePlayers[currentPlayer])
            return nextState('skip figure')
        else
            return AIMoveFigureToLocation()
        end
    elseif turnState == 'wait for flier roll' then
        gameNotification("AI not implemented for expansion: The Fliers", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --gameNotification("MESSAGE_FLIER_DIE_PROMPT", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'awaiting flier decision' then
        gameNotification("AI not implemented for expansion: The Fliers", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --gameNotification("MESSAGE_FLIER_PROMPT", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'post figure event - prompt shepherd' then
        if shepherdAwaitingAction ~= nil then
            startLuaCoroutine(self, 'AIChooseShepherdAction')
        else
            return nextState('next')
        end
    elseif turnState == 'awaiting phantom decision' then
        gameNotification("AI not implemented for expansion: The Phantoms", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'wait for flier roll - phantom' then
        gameNotification("AI not implemented for expansion: The Fliers", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'awaiting flier decision - phantom' then
        gameNotification("AI not implemented for expansion: The Fliers", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
    elseif turnState == 'post figure event - dragon movement' then
        gameNotification("AI not implemented for expansion: The Princess & The Dragon", NEUTRAL_COLOR, activePlayers[currentPlayer])
        return
        --if currentMiniTurn > #activePlayers then currentMiniTurn = 1 end
        --if dragonMovesRemaining > 0 then
        --    return createDragonButtons()
        --else
        --    return nextState('next')
        --end
    --elseif turnState == 'replace finished wagons' then
    --    gameNotification("AI not implemented for expansion: The Abbey & The Mayor", NEUTRAL_COLOR, activePlayers[currentPlayer])
        --return replaceFinishedWagons()
    else
        return playerStateHandler()
    end
end

unusedTiles = {}
buriedTiles = {}
buriedTileCount = 0

function AIMemorizeCards(tileStack)
    --allGameMessage("Please wait while the AI memorizes the tiles...", NEUTRAL_COLOR)
    unusedTiles = {}
    local anchor = getObjectFromGUID(BUTTON_ANCHOR_GUID) --I use the anchor as a temporary placeholder for the script because it is a spare object that players shouldn't interact with. There's no other real reason.
    for i, tile in ipairs(tileStack.getObjects()) do
        anchor = anchor.reload()
        anchor.setLuaScript(tile.lua_script)
        coroutine.yield(0)
        unusedTiles[tile.guid] = {}
        -- unusedTiles[tile.guid].isStartingPiece = anchor.getVar('isStartingPiece')
        unusedTiles[tile.guid].symmetry = anchor.getVar("symmetry")
        unusedTiles[tile.guid].sides = anchor.getTable("sides")
        unusedTiles[tile.guid].linkedQuadrants = anchor.getTable("linkedQuadrants")
        unusedTiles[tile.guid].linkedOctants = anchor.getTable("linkedOctants")
        --unusedTiles[tile.guid].specialFeatures = anchor.getTable("specialFeatures")
    end

    --also include tiles that were buried under hills, since the AI should not be aware of this
    for guid, tile in pairs(buriedTiles) do
        unusedTiles[guid] = {}
        -- unusedTiles[tile.guid].isStartingPiece = anchor.getVar('isStartingPiece')
        unusedTiles[guid].symmetry = tile.symmetry
        unusedTiles[guid].sides = tile.sides
        unusedTiles[guid].linkedQuadrants = tile.linkedQuadrants
        unusedTiles[guid].linkedOctants = tile.linkedOctants
    end
    -- if forkTile_GUID ~= nil then
    --     local forkTile = getObjectFromGUID(forkTile_GUID)
    --     if forkTile ~= nil then
    --         unusedTiles[forkTile_GUID] = {}
    --         unusedTiles[forkTile_GUID].isStartingPiece = anchor.getVar('isStartingPiece')
    --         unusedTiles[forkTile_GUID].sides = forkTile.getTable("sides")
    --         unusedTiles[forkTile_GUID].linkedQuadrants = forkTile.getTable("linkedQuadrants")
    --         unusedTiles[forkTile_GUID].linkedOctants = forkTile.getTable("linkedOctants")
    --         --unusedTiles[forkTile_GUID].specialFeatures = forkTile.getTable("specialFeatures")
    --     end
    -- end
    -- if riverBodyTiles_GUID ~= nil then
    --     local riverStack = getObjectFromGUID(riverBodyTiles_GUID)
    --     if riverStack ~= nil then
    --         for i, tile in ipairs(riverStack.getObjects()) do
    --             anchor = anchor.reload()
    --             anchor.setLuaScript(tile.lua_script)
    --             coroutine.yield(0)
    --             unusedTiles[tile.guid] = {}
    --             unusedTiles[tile.guid].isStartingPiece = anchor.getVar('isStartingPiece')
    --             unusedTiles[tile.guid].sides = anchor.getTable("sides")
    --             unusedTiles[tile.guid].linkedQuadrants = anchor.getTable("linkedQuadrants")
    --             unusedTiles[tile.guid].linkedOctants = anchor.getTable("linkedOctants")
    --             --unusedTiles[tile.guid].specialFeatures = anchor.getTable("specialFeatures")
    --         end
    --     end
    -- end
    -- if finalRiverTile_GUID ~= nil then
    --     local finalRiverTile = getObjectFromGUID(finalRiverTile_GUID)
    --     if finalRiverTile ~= nil then
    --         unusedTiles[finalRiverTile_GUID] = {}
    --         unusedTiles[finalRiverTile_GUID].isStartingPiece = finalRiverTile.getVar('isStartingPiece')
    --         unusedTiles[finalRiverTile_GUID].sides = finalRiverTile.getTable("sides")
    --         unusedTiles[finalRiverTile_GUID].linkedQuadrants = finalRiverTile.getTable("linkedQuadrants")
    --         unusedTiles[finalRiverTile_GUID].linkedOctants = finalRiverTile.getTable("linkedOctants")
    --         --unusedTiles[finalRiverTile_GUID].specialFeatures = finalRiverTile.getTable("specialFeatures")
    --     end
    -- end
    -- if springTile_GUID ~= nil then
    --     local springTile = getObjectFromGUID(springTile_GUID)
    --     if springTile ~= nil then
    --         unusedTiles[springTile_GUID] = {}
    --         unusedTiles[springTile_GUID].isStartingPiece = springTile.getVar('isStartingPiece')
    --         unusedTiles[springTile_GUID].sides = springTile.getTable("sides")
    --         unusedTiles[springTile_GUID].linkedQuadrants = springTile.getTable("linkedQuadrants")
    --         unusedTiles[springTile_GUID].linkedOctants = springTile.getTable("linkedOctants")
    --         --unusedTiles[springTile_GUID].specialFeatures = springTile.getTable("specialFeatures")
    --     end
    -- end
    -- if lakeTile_GUID ~= nil then
    --     local lakeTile = getObjectFromGUID(lakeTile_GUID)
    --     if lakeTile ~= nil then
    --         unusedTiles[lakeTile_GUID] = {}
    --         unusedTiles[lakeTile_GUID].isStartingPiece = lakeTile.getVar('isStartingPiece')
    --         unusedTiles[lakeTile_GUID].sides = lakeTile.getTable("sides")
    --         unusedTiles[lakeTile_GUID].linkedQuadrants = lakeTile.getTable("linkedQuadrants")
    --         unusedTiles[lakeTile_GUID].linkedOctants = lakeTile.getTable("linkedOctants")
    --         --unusedTiles[tile.guid].specialFeatures = lakeTile.getTable("specialFeatures")
    --     end
    -- end
    anchor.setLuaScript("")
end

--validTileLocations keeps a list of valid tiles in each open position adjacent to at least one tile
--tileConnectionOdds keeps a list of possible combinations that can be achieved using the current unusedTiles

--AITileAdded is called after addTile has completed. It will
--remove tiles from adjacent validTileLocations that have been invalidated by the move
--It will then call AICalculateLocationOdds to recompile the possible odds for those locations
--For non-adjacent open locations, it will call AIRemoveTileOdds to more quickly recalculate the odds of those
--locations by removing the connections of that single tile
function AITileAdded(xIndex, zIndex, addedTile, rotation, temp)
    --debugMessage(1, "AITileAdded x:" .. xIndex .. " z:" .. zIndex)
    local targetValidTileLocations
    local targetTileConnectionOdds
    if temp then
        tempValidTileLocations = table.deep_copy(prunedValidTileLocations)
        targetValidTileLocations = tempValidTileLocations
        tempTileConnectionOdds = table.deep_copy(prunedTileConnectionOdds)
        targetTileConnectionOdds = tempTileConnectionOdds
    else
        targetValidTileLocations = validTileLocations
        targetTileConnectionOdds = tileConnectionOdds
        local addedTileCoord = xIndex .. "-" .. zIndex
        if validTileLocations[addedTileCoord] ~= nil then
            validTileLocations[addedTileCoord] = nil
            tileConnectionOdds[addedTileCoord] = nil
        end
    end
    if not temp and not addedTile.getVar('isStartingPiece') then --since we don't include starting pieces in the tilesRemaining count, don't subtract them or we'll be forced to recalculate
        tilesRemaining = tilesRemaining - 1
    end
    if not temp then
        if unusedTiles[addedTile.getGUID()] ~= nil then --don't modify the odds if tiles not from the tilestack are added (ie. starting tile)
            for openingCoord, tileTiles in pairs(validTileLocations) do --iterate through all valid tile lists and remove the added tile
                local coord = string.split(openingCoord, "-")
                local xIndex = tonumber(coord[1])
                local zIndex = tonumber(coord[2])
                AIRemoveTileOdds(openingCoord, xIndex, zIndex, addedTile.getGUID(), targetTileConnectionOdds[openingCoord])
                tileTiles[addedTile.getGUID()] = nil
            end
        end
        unusedTiles[addedTile.getGUID()] = nil --remove the added tile from the list of unused tiles
    end
    for side, sideDelta in ipairs(SIDE_DELTA) do
        local nestedX = xIndex + sideDelta.x
        local nestedZ = zIndex + sideDelta.z
        if not tileGridOccupied(nestedX, nestedZ) then
            if (nestedX >= MIN_X and nestedX <= MAX_X and nestedZ >= MIN_Z and nestedZ <= MAX_Z) then
                local openingCoord = nestedX .. '-' .. nestedZ
                if validTileLocations[openingCoord] == nil then --this is a new tile location
                    targetValidTileLocations[openingCoord] = {}
                    for unusedTile_GUID, unusedTile in pairs(unusedTiles) do
                        if unusedTile_GUID ~= addedTile.getGUID() then
                            local validRotations = unusedTile.symmetry
                            if validRotations == nil then validRotations = 4 end
                            for unusedTileRotation=1, validRotations do
                                local isValid = true
                                if addedTile.getTable('sides')[(3 + side - rotation) % 4 + 1] == unusedTile.sides[(3 + side - unusedTileRotation + TILE_180_ROTATION) % 4 + 1] then
                                    if validTileLocations[openingCoord] == nil or validTileLocations[openingCoord][unusedTile_GUID] == nil then
                                        targetValidTileLocations[openingCoord][unusedTile_GUID] = {}
                                    end
                                    targetValidTileLocations[openingCoord][unusedTile_GUID][unusedTileRotation] = true
                                end
                            end
                        end
                    end
                else --this tile location already exists. Filter it by the given tile
                    if temp then
                        tempValidTileLocations[openingCoord] = {}
                    end
                    for validTile_GUID, validTileRotations in pairs(validTileLocations[openingCoord]) do
                        if validTile_GUID ~= addedTile.getGUID() then
                            local keptOne = false
                            for validTileRotation, _ in pairs(validTileRotations) do
                                if addedTile.getTable('sides')[(3 + side - rotation) % 4 + 1] == unusedTiles[validTile_GUID].sides[(3 + side - validTileRotation + TILE_180_ROTATION) % 4 + 1] then
                                    keptOne = true
                                    if temp then
                                        if tempValidTileLocations[openingCoord][validTile_GUID] == nil then tempValidTileLocations[openingCoord][validTile_GUID] = {} end
                                        tempValidTileLocations[openingCoord][validTile_GUID][validTileRotation] = true
                                    end
                                elseif not temp then
                                    validTileLocations[openingCoord][validTile_GUID][validTileRotation] = nil
                                end
                            end
                            if (not keptOne) and (not temp) then
                                validTileLocations[openingCoord][validTile_GUID] = nil
                            end
                        else --do not include the tile that was added
                            targetValidTileLocations[openingCoord][validTile_GUID] = nil
                        end
                    end
                end
                --TODO: Need to add abbey valid moves when all 4 sides are filled in
                --TODO: Need to invalidate cult tile conflicts
                targetTileConnectionOdds[openingCoord] = AICalculateLocationOdds(openingCoord, nestedX, nestedZ, xIndex, zIndex, temp)
            end
        end
    end
end

--when a tile is drawn by the AI, calculate in advance the change in validTileLocations and tileConnectionOdds, since those will be the same for every position
function AIMakeTileUnavailable(drawnTile)
    prunedValidTileLocations = {}
    prunedTileConnectionOdds = table.deep_copy(tileConnectionOdds)

    if unusedTiles[drawnTile.getGUID()] ~= nil then --don't modify the odds if tiles not from the tilestack are added (ie. starting tile)
        for openingCoord, tileTiles in pairs(validTileLocations) do --iterate through all valid tile lists and remove the added tile
            prunedValidTileLocations[openingCoord] = table.shallow_copy(validTileLocations[openingCoord])
            local coord = string.split(openingCoord, "-")
            local xIndex = tonumber(coord[1])
            local zIndex = tonumber(coord[2])
            AIRemoveTileOdds(openingCoord, xIndex, zIndex, drawnTile.getGUID(), prunedTileConnectionOdds[openingCoord])
        end
    end
end

function AITileBuried(buriedTile)
    buriedTiles[buriedTile.getGUID()] = {}
    -- unusedTiles[tile.guid].isStartingPiece = anchor.getVar('isStartingPiece')
    buriedTiles[buriedTile.getGUID()].symmetry = buriedTile.getVar("symmetry")
    buriedTiles[buriedTile.getGUID()].sides = buriedTile.getTable("sides")
    buriedTiles[buriedTile.getGUID()].linkedQuadrants = buriedTile.getTable("linkedQuadrants")
    buriedTiles[buriedTile.getGUID()].linkedOctants = buriedTile.getTable("linkedOctants")
    buriedTiles[buriedTile.getGUID()] = true
    buriedTileCount = buriedTileCount + 1
    tilesRemaining = tilesRemaining - 1
end

--Calculate the possible combinations of connections or lack thereof
--using the validTileLocations and unusedTiles data structures
function AICalculateLocationOdds(openingCoord, xIndex, zIndex, addedTileXIndex, addedTileZIndex, temp)
    if temp and getPlayerOwner(activePlayers[currentPlayer]) ~= 'AIHard (Beta)' then return nil end
    --debugMessage(1, "calculating odds at x:" .. xIndex .. " z:" .. zIndex)
    local connectionOdds = {}
    connectionOdds["blocked"] = tilesRemaining + buriedTileCount
    connectionOdds["valid"] = 0
    connectionOdds["totalValid"] = 0
    local validTiles
    if temp and tempValidTileLocations[openingCoord] ~= nil then
        validTiles = tempValidTileLocations[openingCoord]
    else
        validTiles = validTileLocations[openingCoord]
    end
    for validTile_GUID, validTileRotations in pairs(validTiles) do
        for validTileRotation, _ in pairs(validTileRotations) do
            connectionOdds["totalValid"] = connectionOdds["totalValid"] + 1
            local visitedFeatures = {}
            for position=1, 12 do
                local nameOfFeature
                if position < 5 then
                    nameOfFeature = unusedTiles[validTile_GUID].sides[position]
                else--if position < 13 then
                    nameOfFeature = unusedTiles[validTile_GUID].sides[math.floor((position - 3) / 2)]
                end
                if (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' or nameOfFeature == 'Abbey') and not visitedFeatures[position] then
                    local connectedFeatures = {}
                    local numOpenings = 0
                    local links = nil

                    if position < 5 then
                        links = unusedTiles[validTile_GUID].linkedQuadrants
                    else--if position < 13 then
                        links = unusedTiles[validTile_GUID].linkedOctants
                    end
                    local visitedPosition = false
                    while not visitedPosition do
                        if links ~= nil then
                            for _, link in ipairs(links) do
                                --HACK: Because quadrants and octants can't be linked, Abbeys create a scenario where they get different feature numbers.
                                --The least hacky way I could fix it (without having to redo huge chunks of code) was as follows, in addition to linking all 12 positions to the 13th on the tiles...
                                if nameOfFeature == 'Abbey' and position < 13 then
                                    link = {1,2,3,4,5,6,7,8,9,10,11,12}
                                end
                                if table.contains(link, position) then
                                    visitedPosition = true
                                    for _, nestedTilePosition in ipairs(link) do
                                        visitedFeatures[nestedTilePosition] = true
                                        if nestedTilePosition < 13 then
                                            local connectedFeatureMapPosition, connectedX, connectedZ = getConnectingFeatureMapPosition(xIndex, zIndex, nestedTilePosition, validTileRotation)
                                            if nameOfFeature ~= 'Abbey' then
                                                if tileGridOccupied(connectedX, connectedZ) and tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition] ~= nil then
                                                    table.bininsertnodup(connectedFeatures, tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition])
                                                else
                                                    numOpenings = numOpenings + 1
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if not visitedPosition then
                            links = {{position}}
                        end
                    end
                    if #connectedFeatures > 1 then
                        local key = ""
                        -- if #connectedFeatures == 1 then -- this tile extends only 1 feature
                        --     if numOpenings == 0 then -- this piece closes the feature that is connected
                        --         key = "close+" .. connectedFeatures[1]
                        --     else -- this piece extends the feature that is connected
                        --         key = "extend+" .. connectedFeatures[1]
                        --     end
                        -- else -- this tile combines more than 1 feature
                            key = table.concat(connectedFeatures, '+')
                        -- end
                        if connectionOdds[key] == nil then
                            connectionOdds[key] = 1
                        else
                            connectionOdds[key] = connectionOdds[key] + 1
                        end
                    end
                end
            end
        end
        connectionOdds["blocked"] = connectionOdds["blocked"] - 1
        connectionOdds["valid"] = connectionOdds["valid"] + 1
    end

    if connectionOdds["blocked"] + connectionOdds["valid"] ~= tilesRemaining + buriedTileCount then
        if not alreadyPrintedErrorMessage then
            --print("ERROR: calculated odds incorrect at x:" .. xIndex .. " z:" .. zIndex .. " blocked:" .. connectionOdds["blocked"] .. " valid:" .. connectionOdds["valid"] .. " remaining:" .. tilesRemaining)
            debugMessage(1, "ERROR: calculated odds incorrect at x:" .. xIndex .. " z:" .. zIndex .. " blocked:" .. connectionOdds["blocked"] .. " valid:" .. connectionOdds["valid"] .. " remaining:" .. tilesRemaining)
            alreadyPrintedErrorMessage = true
        end
    end
    return connectionOdds
end

--Modify the connection odds of this position by subtracting the valid connections
--of the removed tile
function AIRemoveTileOdds(openingCoord, xIndex, zIndex, removedTile_GUID, connectionOdds)
    if validTileLocations[openingCoord][removedTile_GUID] ~= nil then
        for validTileRotation, _ in pairs(validTileLocations[openingCoord][removedTile_GUID]) do
            connectionOdds["totalValid"] = connectionOdds["totalValid"] - 1
            local visitedFeatures = {}
            for position=1, 12 do
                local nameOfFeature
                if position < 5 then
                    nameOfFeature = unusedTiles[removedTile_GUID].sides[position]
                else--if position < 13 then
                    nameOfFeature = unusedTiles[removedTile_GUID].sides[math.floor((position - 3) / 2)]
                end
                if (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' or nameOfFeature == 'Abbey') and not visitedFeatures[position] then
                    local connectedFeatures = {}
                    local numOpenings = 0
                    local links = nil

                    if position < 5 then
                        links = unusedTiles[removedTile_GUID].linkedQuadrants
                    else--if position < 13 then
                        links = unusedTiles[removedTile_GUID].linkedOctants
                    end
                    local visitedPosition = false
                    while not visitedPosition do
                        if links ~= nil then
                            for _, link in ipairs(links) do
                                --HACK: Because quadrants and octants can't be linked, Abbeys create a scenario where they get different feature numbers.
                                --The least hacky way I could fix it (without having to redo huge chunks of code) was as follows, in addition to linking all 12 positions to the 13th on the tiles...
                                if nameOfFeature == 'Abbey' and position < 13 then
                                    link = {1,2,3,4,5,6,7,8,9,10,11,12}
                                end
                                if table.contains(link, position) then
                                    visitedPosition = true
                                    for _, nestedTilePosition in ipairs(link) do
                                        visitedFeatures[nestedTilePosition] = true
                                        if nestedTilePosition < 13 then
                                            local connectedFeatureMapPosition, connectedX, connectedZ = getConnectingFeatureMapPosition(xIndex, zIndex, nestedTilePosition, validTileRotation)
                                            if nameOfFeature ~= 'Abbey' then
                                                if tileGridOccupied(connectedX, connectedZ) and tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition] ~= nil then
                                                    table.bininsertnodup(connectedFeatures, tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition])
                                                else
                                                    numOpenings = numOpenings + 1
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if not visitedPosition then
                            links = {{position}}
                        end
                    end
                    if #connectedFeatures > 1 then
                        local key = ""
                        -- if #connectedFeatures == 1 then -- this tile extends only 1 feature
                        --     if numOpenings == 0 then -- this piece closes the feature that is connected
                        --         key = "close+" .. connectedFeatures[1]
                        --     else -- this piece extends the feature that is connected
                        --         key = "extend+" .. connectedFeatures[1]
                        --     end
                        -- else -- this tile combines more than 1 feature
                            key = table.concat(connectedFeatures, '+')
                        -- end
                        if connectionOdds[key] ~= nil then
                            connectionOdds[key] = connectionOdds[key] - 1
                            if connectionOdds[key] == 0 then
                                connectionOdds[key] = nil
                            end
                        end
                    end
                end
            end
        end
        connectionOdds["valid"] = connectionOdds["valid"] - 1
    else
        connectionOdds["blocked"] = connectionOdds["blocked"] - 1
    end

    if connectionOdds["blocked"] + connectionOdds["valid"] ~= tilesRemaining + buriedTileCount then
        if not alreadyPrintedErrorMessage then
            --print("ERROR: removed " .. removedTile_GUID .. " at x:" .. xIndex .. " z:" .. zIndex .. " blocked:" .. connectionOdds["blocked"] .. " valid:" .. connectionOdds["valid"] .. " remaining:" .. tilesRemaining)
            debugMessage(1, "ERROR: removed " .. removedTile_GUID .. " at x:" .. xIndex .. " z:" .. zIndex .. " blocked:" .. connectionOdds["blocked"] .. " valid:" .. connectionOdds["valid"] .. " remaining:" .. tilesRemaining + buriedTileCount)
            alreadyPrintedErrorMessage = true
        end
    end
end

--AITileRemoved is called after removeTile has completed. It will
--add tiles to adjacent validTileLocations that have been made once again valid by the move
--It will then call AICalculateLocationOdds to recompile the possible odds for those locations
--For non-adjacent open locations, it will call AIAddTileOdds to more quickly recalculate the odds of those
--locations by removing the connections of that single tile
function AITileRemoved(xIndex, zIndex, removedTile)
    unusedTiles[removedTile.guid] = {}
    local symmetry = removedTile.getVar("symmetry")
    -- unusedTiles[tile.guid].isStartingPiece = anchor.getVar('isStartingPiece')
    unusedTiles[removedTile.guid].symmetry = symmetry
    unusedTiles[removedTile.guid].sides = removedTile.getTable("sides")
    unusedTiles[removedTile.guid].linkedQuadrants = removedTile.getTable("linkedQuadrants")
    unusedTiles[removedTile.guid].linkedOctants = removedTile.getTable("linkedOctants")
    --unusedTiles[removedTile.guid].specialFeatures = removedTile.getTable("specialFeatures")

    tilesRemaining = tilesRemaining + 1

    for openingCoord, tileTiles in pairs(validTileLocations) do --iterate through all valid tile lists and add the removed tile
        local validRotations = symmetry
        if validRotations == nil then validRotations = 4 end
        local coord = string.split(openingCoord, "-")
        local xIndex = tonumber(coord[1])
        local zIndex = tonumber(coord[2])
        for tileRotation=1, validRotations do
            if isValidTileLocation(removedTile, tileRotation, xIndex, zIndex, false) then
                if tileTiles[removedTile.getGUID()] == nil then
                    tileTiles[removedTile.getGUID()] = {}
                end
                tileTiles[removedTile.getGUID()][tileRotation] = true
            end
        end
        AIAddTileOdds(openingCoord, xIndex, zIndex, removedTile.getGUID(), tileConnectionOdds[openingCoord])
    end

    local removedTileCoord = xIndex .. "-" .. zIndex
    validTileLocations[removedTileCoord] = {}
    for unusedTile_GUID, unusedTile in pairs(unusedTiles) do
        local validRotations = unusedTile.symmetry
        if validRotations == nil then validRotations = 4 end
        for tileRotation=1, validRotations do --rebuild validTileLocations at the location the tile was removed
            if ((not tileGridOccupied(xIndex + 1, zIndex) or unusedTile.sides[(3 + 4 - tileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[xIndex + 1][zIndex].tile_guid).getTable('sides')[(3 + 4 - tileGrid[xIndex + 1][zIndex].rotation + TILE_180_ROTATION) % 4 + 1]) and
                (not tileGridOccupied(xIndex - 1, zIndex) or unusedTile.sides[(3 + 2 - tileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[xIndex - 1][zIndex].tile_guid).getTable('sides')[(3 + 2 - tileGrid[xIndex - 1][zIndex].rotation + TILE_180_ROTATION) % 4 + 1]) and
                (not tileGridOccupied(xIndex, zIndex + 1) or unusedTile.sides[(3 + 3 - tileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[xIndex][zIndex + 1].tile_guid).getTable('sides')[(3 + 3 - tileGrid[xIndex][zIndex + 1].rotation + TILE_180_ROTATION) % 4 + 1]) and
                (not tileGridOccupied(xIndex, zIndex - 1) or unusedTile.sides[(3 + 1 - tileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[xIndex][zIndex - 1].tile_guid).getTable('sides')[(3 + 1 - tileGrid[xIndex][zIndex - 1].rotation + TILE_180_ROTATION) % 4 + 1])) then
                if validTileLocations[removedTileCoord][unusedTile_GUID] == nil then
                    validTileLocations[removedTileCoord][unusedTile_GUID] = {}
                end
                validTileLocations[removedTileCoord][unusedTile_GUID][tileRotation] = true
            end
        end
    end
    tileConnectionOdds[removedTileCoord] = AICalculateLocationOdds(removedTileCoord, xIndex, zIndex, nil, nil, false)
    --rebuild validTileLocations at the locations next to the removed tile
    for side, sideDelta in ipairs(SIDE_DELTA) do
        local nestedX = xIndex + sideDelta.x
        local nestedZ = zIndex + sideDelta.z
        local openingCoord = nestedX .. '-' .. nestedZ
        if not tileGridOccupied(nestedX, nestedZ) then
            local hasNeighbor = false
            for nested_side, nested_sideDelta in ipairs(SIDE_DELTA) do
                if tileGridOccupied(nestedX + nested_sideDelta.x, nestedZ + nested_sideDelta.z) then
                    hasNeighbor = true
                    break
                end
            end
            if hasNeighbor then
                for unusedTile_GUID, unusedTile in pairs(unusedTiles) do
                    if validTileLocations[openingCoord][unusedTile_GUID] == nil then
                        validTileLocations[openingCoord][unusedTile_GUID] = {}
                        local validRotations = unusedTile.symmetry
                        if validRotations == nil then validRotations = 4 end
                        for unusedTileRotation=1, validRotations do
                            if ((not tileGridOccupied(nestedX + 1, nestedZ) or unusedTile.sides[(3 + 4 - unusedTileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[nestedX + 1][nestedZ].tile_guid).getTable('sides')[(3 + 4 - tileGrid[nestedX + 1][nestedZ].rotation + TILE_180_ROTATION) % 4 + 1]) and
                                (not tileGridOccupied(nestedX - 1, nestedZ) or unusedTile.sides[(3 + 2 - unusedTileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[nestedX - 1][nestedZ].tile_guid).getTable('sides')[(3 + 2 - tileGrid[nestedX - 1][nestedZ].rotation + TILE_180_ROTATION) % 4 + 1]) and
                                (not tileGridOccupied(nestedX, nestedZ + 1) or unusedTile.sides[(3 + 3 - unusedTileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[nestedX][nestedZ + 1].tile_guid).getTable('sides')[(3 + 3 - tileGrid[nestedX][nestedZ + 1].rotation + TILE_180_ROTATION) % 4 + 1]) and
                                (not tileGridOccupied(nestedX, nestedZ - 1) or unusedTile.sides[(3 + 1 - unusedTileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[nestedX][nestedZ - 1].tile_guid).getTable('sides')[(3 + 1 - tileGrid[nestedX][nestedZ - 1].rotation + TILE_180_ROTATION) % 4 + 1])) then
                                validTileLocations[openingCoord][unusedTile_GUID][unusedTileRotation] = true
                            end
                        end
                    end
                end
                tileConnectionOdds[openingCoord] = AICalculateLocationOdds(openingCoord, nestedX, nestedZ, nil, nil, false)
            else
                validTileLocations[openingCoord] = nil
                tileConnectionOdds[openingCoord] = nil
            end
        end
    end
end

function AIAddTileOdds(openingCoord, xIndex, zIndex, addedTile_GUID, connectionOdds)
    if validTileLocations[openingCoord][addedTile_GUID] ~= nil then
        for validTileRotation, _ in pairs(validTileLocations[openingCoord][addedTile_GUID]) do
            connectionOdds["totalValid"] = connectionOdds["totalValid"] + 1
            local visitedFeatures = {}
            for position=1, 12 do
                local nameOfFeature
                if position < 5 then
                    nameOfFeature = unusedTiles[addedTile_GUID].sides[position]
                else--if position < 13 then
                    nameOfFeature = unusedTiles[addedTile_GUID].sides[math.floor((position - 3) / 2)]
                end
                if (position > 4 or nameOfFeature == 'Road' or nameOfFeature == 'River' or nameOfFeature == 'Abbey') and not visitedFeatures[position] then
                    local connectedFeatures = {}
                    local numOpenings = 0
                    local links = nil

                    if position < 5 then
                        links = unusedTiles[addedTile_GUID].linkedQuadrants
                    else--if position < 13 then
                        links = unusedTiles[addedTile_GUID].linkedOctants
                    end
                    local visitedPosition = false
                    while not visitedPosition do
                        if links ~= nil then
                            for _, link in ipairs(links) do
                                --HACK: Because quadrants and octants can't be linked, Abbeys create a scenario where they get different feature numbers.
                                --The least hacky way I could fix it (without having to redo huge chunks of code) was as follows, in addition to linking all 12 positions to the 13th on the tiles...
                                if nameOfFeature == 'Abbey' and position < 13 then
                                    link = {1,2,3,4,5,6,7,8,9,10,11,12}
                                end
                                if table.contains(link, position) then
                                    visitedPosition = true
                                    for _, nestedTilePosition in ipairs(link) do
                                        visitedFeatures[nestedTilePosition] = true
                                        if nestedTilePosition < 13 then
                                            local connectedFeatureMapPosition, connectedX, connectedZ = getConnectingFeatureMapPosition(xIndex, zIndex, nestedTilePosition, validTileRotation)
                                            if nameOfFeature ~= 'Abbey' then
                                                if tileGridOccupied(connectedX, connectedZ) and tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition] ~= nil then
                                                    table.bininsertnodup(connectedFeatures, tileGrid[connectedX][connectedZ].featureMap[connectedFeatureMapPosition])
                                                else
                                                    numOpenings = numOpenings + 1
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        if not visitedPosition then
                            links = {{position}}
                        end
                    end
                    if #connectedFeatures > 1 then
                        local key = ""
                        -- if #connectedFeatures == 1 then -- this tile extends only 1 feature
                        --     if numOpenings == 0 then -- this piece closes the feature that is connected
                        --         key = "close+" .. connectedFeatures[1]
                        --     else -- this piece extends the feature that is connected
                        --         key = "extend+" .. connectedFeatures[1]
                        --     end
                        -- else -- this tile combines more than 1 feature
                            key = table.concat(connectedFeatures, '+')
                        -- end
                        if connectionOdds[key] ~= nil then
                            connectionOdds[key] = connectionOdds[key] + 1
                            if connectionOdds[key] == 0 then
                                connectionOdds[key] = nil
                            end
                        end
                    end
                end
            end
        end
        connectionOdds["valid"] = connectionOdds["valid"] + 1
    else
        connectionOdds["blocked"] = connectionOdds["blocked"] + 1
    end
end

--iterate through all openings and recalculate valid tiles and odds from scratch
function AIRecalculateOdds()
    for openingCoord, _ in pairs(validTileLocations) do --iterate through all valid tile lists and add the removed tile
        validTileLocations[openingCoord] = {}
        local coord = string.split(openingCoord, "-")
        local xIndex = tonumber(coord[1])
        local zIndex = tonumber(coord[2])
        for unusedTile_GUID, unusedTile in pairs(unusedTiles) do
            validTileLocations[openingCoord][unusedTile_GUID] = {}
            local validRotations = unusedTile.symmetry
            if validRotations == nil then validRotations = 4 end
            for unusedTileRotation=1, validRotations do
                if ((not tileGridOccupied(xIndex + 1, zIndex) or unusedTile.sides[(3 + 4 - unusedTileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[xIndex + 1][zIndex].tile_guid).getTable('sides')[(3 + 4 - tileGrid[xIndex + 1][zIndex].rotation + TILE_180_ROTATION) % 4 + 1]) and
                    (not tileGridOccupied(xIndex - 1, zIndex) or unusedTile.sides[(3 + 2 - unusedTileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[xIndex - 1][zIndex].tile_guid).getTable('sides')[(3 + 2 - tileGrid[xIndex - 1][zIndex].rotation + TILE_180_ROTATION) % 4 + 1]) and
                    (not tileGridOccupied(xIndex, zIndex + 1) or unusedTile.sides[(3 + 3 - unusedTileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[xIndex][zIndex + 1].tile_guid).getTable('sides')[(3 + 3 - tileGrid[xIndex][zIndex + 1].rotation + TILE_180_ROTATION) % 4 + 1]) and
                    (not tileGridOccupied(xIndex, zIndex - 1) or unusedTile.sides[(3 + 1 - unusedTileRotation) % 4 + 1] == getObjectFromGUID(tileGrid[xIndex][zIndex - 1].tile_guid).getTable('sides')[(3 + 1 - tileGrid[xIndex][zIndex - 1].rotation + TILE_180_ROTATION) % 4 + 1])) then
                    validTileLocations[openingCoord][unusedTile_GUID][unusedTileRotation] = true
                end
            end
        end
        tileConnectionOdds[openingCoord] = AICalculateLocationOdds(openingCoord, xIndex, zIndex, nil, nil, false)
    end
end

function AIChooseTileLocation()
    --debugMessage(2, "AI choosing tile location...")
    local tileStack = getObjectFromGUID(tileStack_GUID)
    actualTilesRemaining = 0
    if tileStack ~= nil then
        actualTilesRemaining = tileStack.getQuantity()
    elseif finalTile_GUID ~= nil then
        actualTilesRemaining = 1
    end
    numRemainingMoves = math.floor(actualTilesRemaining / #activePlayers) --since the currently drawn tile isn't included, we'll need to add one on some calculations

    if tileStack ~= nil and actualTilesRemaining ~= tilesRemaining then
        allGameMessage({"MESSAGE_AI_RECALCULATING_ODDS"}, ERROR_COLOR, nil)
        tilesRemaining = actualTilesRemaining
        AIMemorizeCards(tileStack)
        AIRecalculateOdds()
        allGameMessage({"MESSAGE_AI_FINISHED_RECALCULATING_ODDS"}, ERROR_COLOR, nil)
    end

    local newTile = nil
    local isRiverPiece = false
    local handPosition = {Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_x, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_y, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_z}
    if controlPanelSettings['StartingTileRiverII'] or controlPanelSettings['StartingTileRiver'] or controlPanelSettings['StartingTileRiverBB5'] then
        if forkTile_GUID ~= nil and getObjectFromGUID(forkTile_GUID) ~= nil then
            isRiverPiece = true
            newTile = getObjectFromGUID(forkTile_GUID)
            if AI_DRAW_TILE_TO_HAND then
                newTile.setPositionSmooth(handPosition)
            else
                dealInFrontOfHand(newTile, handColor[activePlayers[currentPlayer]], false)
            end
        elseif riverBodyTiles_GUID ~= nil and getObjectFromGUID(riverBodyTiles_GUID) ~= nil then
            isRiverPiece = true
            local riverStack = getObjectFromGUID(riverBodyTiles_GUID)
            if riverStack ~= nil then
                if AI_DRAW_TILE_TO_HAND then
                    newTile = riverStack.dealToColorWithOffset( {0,0,0}, true, handColor[activePlayers[currentPlayer]])
                else
                    newTile = dealInFrontOfHand(riverStack, handColor[activePlayers[currentPlayer]], true)
                end
            end
        elseif finalRiverTile_GUID ~= nil and getObjectFromGUID(finalRiverTile_GUID) ~= nil then
            isRiverPiece = true
            newTile = getObjectFromGUID(finalRiverTile_GUID)
            if AI_DRAW_TILE_TO_HAND then
                newTile.setPositionSmooth(handPosition)
            else
                dealInFrontOfHand(newTile, handColor[activePlayers[currentPlayer]], false)
            end
        elseif springTile_GUID ~= nil and getObjectFromGUID(springTile_GUID) ~= nil then
            isRiverPiece = true
            newTile = getObjectFromGUID(springTile_GUID)
            if AI_DRAW_TILE_TO_HAND then
                newTile.setPositionSmooth(handPosition)
            else
                dealInFrontOfHand(newTile, handColor[activePlayers[currentPlayer]], false)
            end
        elseif lakeTile_GUID ~= nil and getObjectFromGUID(lakeTile_GUID) ~= nil then
            isRiverPiece = true
            newTile = getObjectFromGUID(lakeTile_GUID)
            if AI_DRAW_TILE_TO_HAND then
                newTile.setPositionSmooth(handPosition)
            else
                dealInFrontOfHand(newTile, handColor[activePlayers[currentPlayer]], false)
            end
        end
        if newTile ~= nil then
            alreadyFound = true
        end
    end
    if newTile == nil then
        if tileStack ~= nil then
            if AI_DRAW_TILE_TO_HAND then
            newTile = tileStack.dealToColorWithOffset( {0,0,0}, true, handColor[activePlayers[currentPlayer]])
            else
                newTile = dealInFrontOfHand(tileStack, handColor[activePlayers[currentPlayer]], true)
            end
            --getObjectFromGUID(tileStack_GUID).dealToColor(1, getCurrentPlayerOwner())
        elseif finalTile_GUID ~= nil then
            newTile = getObjectFromGUID(finalTile_GUID)
            if AI_DRAW_TILE_TO_HAND then
                local handPosition = {Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_x, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_y, Player[handColor[activePlayers[currentPlayer]]].getPlayerHand().pos_z}
                newTile.setPositionSmooth(handPosition)
            else
                dealInFrontOfHand(newTile, handColor[activePlayers[currentPlayer]], false)
            end
        else
            allGameMessage({"MESSAGE_AI_GAME_OVER"}, NEUTRAL_COLOR, nil)
            return 1
        end
    else
        tileStack = nil --so that it won't try to return the tile to the tileStack if there is no valid place for it, since it didn't come from the tileStack
    end

    coroutine.yield(0) -- this yield is needed if the tile drawn destroyed the deck, in which case we need to wait for finalTile_GUID to be set

    calculationStart = os.clock()
    lastFrameTime = os.clock()

    UI.show("AIProgressPanel")
    UI.setAttribute("AIProgressPanel", "active", "true")
    UI.setAttribute("AIProgressBar", "percentage", 0.0)

    local CalculateLocationScoreFunction
    if getPlayerOwner(activePlayers[currentPlayer]) == "AIEasy" then
        CalculateLocationScoreFunction = AICalculateLocationScoreEasy
        AICalculateBaselineScoresEasy()
    else
        CalculateLocationScoreFunction = AICalculateTileLocationScore
        AICalculateBaselineScores()
    end

    lastDrawnTile_GUID = newTile.getGUID()
    coroutine.yield(0)

    alreadyPrintedErrorMessage = false -- to prevent excessive spam

    local validRotations = newTile.getVar("symmetry")
    if validRotations == nil then validRotations = 4 end

    if startingTile_GUID ~= nil then
        if isRiverPiece then
            local tileConfigurations = {}
            for xIndex, tileColumn in pairs(tileGrid) do
                for zIndex, tileLocation in pairs(tileColumn) do
                    for side, sideDelta in pairs(SIDE_DELTA) do
                        local nestedX = xIndex + sideDelta.x
                        local nestedZ = zIndex + sideDelta.z
                        if not tileGridOccupied(nestedX, nestedZ) then
                            if tileConfigurations[nestedX] == nil then
                                tileConfigurations[nestedX] = {}
                            end
                            if tileConfigurations[nestedX][nestedZ] == nil then
                                tileConfigurations[nestedX][nestedZ] = true
                                AIMakeTileUnavailable(newTile)
                                for tileRotation=1, validRotations do
                                    if isValidTileLocation(newTile, tileRotation, nestedX, nestedZ, false) then
                                        CalculateLocationScoreFunction(newTile, tileRotation, nestedX, nestedZ)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        else
            local totalValidMoves = 0
            for openingCoord, tileTiles in pairs(validTileLocations) do
                if tileTiles[newTile.getGUID()] ~= nil then
                    for tileRotation, _ in pairs(tileTiles[newTile.getGUID()]) do
                        totalValidMoves = totalValidMoves + 1
                    end
                end
            end
            local completedMoves = 0
            for openingCoord, tileTiles in pairs(validTileLocations) do
                if tileTiles[newTile.getGUID()] ~= nil then
                    local coord = string.split(openingCoord, "-")
                    local xIndex = tonumber(coord[1])
                    local zIndex = tonumber(coord[2])
                    AIMakeTileUnavailable(newTile)
                    for tileRotation, _ in pairs(tileTiles[newTile.getGUID()]) do
                        CalculateLocationScoreFunction(newTile, tileRotation, xIndex, zIndex)
                        completedMoves = completedMoves + 1
                        UI.setAttribute("AIProgressBar", "percentage", 100 * completedMoves / totalValidMoves)
                    end
                end
            end
        end
    else
        highestScoreX = MIDDLE_X_OFFSET
        highestScoreZ = MIDDLE_Z_OFFSET
        highestScoreRot = TILE_STANDARD_ROTATION
    end

    UI.setAttribute("AIProgressPanel", "active", "false")
    UI.hide("AIProgressPanel")

    local posText = highestScorePos
    local figureText = highestScoreFigure
    if highestScorePos == nil then posText = "N/A" end
    if highestScoreFigure == nil then figureText = "None" end
    if highestScoreX ~= nil then
        debugMessage(1, "highest score: " .. highestScore .. " at x:" .. highestScoreX .. " z:" .. highestScoreZ .. " rot:" .. highestScoreRot .. " pos:" .. posText .. " figure: " .. figureText)
        debugMessage(1, "Calculation complete in: " .. os.clock() - calculationStart .. " seconds.")
        if highestScore > AI_TAUNT_THRESHOLD then
            local tauntNum = math.random(#LOCALIZED_TAUNTS[controlPanelSettings['currentLanguage']])
            allGameMessage({"{c1}: {s1}", {'{c1}', getPlayerOwner(activePlayers[currentPlayer])}, {'{s1}', RGBToBracketedHex(WHITE_COLOR) .. LOCALIZED_TAUNTS[controlPanelSettings['currentLanguage']][tauntNum]}}, player_color_tints[activePlayers[currentPlayer]])
        end
        AIMoveTileToLocation(newTile, highestScoreX, highestScoreZ, highestScoreRot)
    else
        allGameMessage({"MESSAGE_AI_NO_LOCATION"}, NEUTRAL_COLOR, nil)
        if tileStack ~= nil then
            tileStack.putObject(newTile)
            wait(2.0)
            tileStack.shuffle()
            wait(0.1)
            AIChooseTileLocation()
        else
            allErrorMessage({"MESSAGE_AI_ERROR_NO_TILESTACK"}, activePlayers[currentPlayer])
        end
    end
    return 1
end

--initialize this so it will compile correctly
function AICalculateBaselineScoresEasy()
    highestScore = -999
    highestScoreX = nil
    highestScoreZ = nil
    highestScoreRot = nil
    highestScorePos = nil
    highestScoreFigure = nil
    numIdenticalScore = 1

    getActiveFigures()
    getActiveNeutralFigures()

    -- for featureNum, figures in pairs(activeFigures) do
    --     local numFollowers = 0
    --     local numFigures = 0
    --     if figures.followers ~= nil then
    --         numFollowers = #figures.followers
    --     end
    --     if figures.specialFigures ~= nil then
    --         numFigures = #figures.specialFigures
    --     end
    --     debugMessage(1, "feature " .. featureNum .. " has " .. numFollowers .. " followers, " .. numFigures .. " special figures.")
    -- end

    --since we haven't joined any features yet, the currently active figures can be used
    joinedActiveFigures = {}
    for featureNum, figureList in pairs(activeFigures) do
        if joinedActiveFigures[featureNum] == nil then
            joinedActiveFigures[featureNum] = {}
            joinedActiveFigures[featureNum].followers = {}
            joinedActiveFigures[featureNum].specialFigures = {}
        end

        for _, follower in ipairs(figureList.followers) do
            local followerXIndex, followerZIndex, _, _ = getFigureTileLocation(follower)
            table.insert(joinedActiveFigures[featureNum].followers, {figureName=follower.getVar('figureName'), owner=follower.getVar('owner'), tile_guid=tileGrid[followerXIndex][followerZIndex].tile_guid})
        end
        for _, figure in ipairs(figureList.specialFigures) do
            table.insert(joinedActiveFigures[featureNum].specialFigures, {figureName=figure.getVar('figureName'), owner=figure.getVar('owner')})
        end
    end
    tempFeatureList = featureList
    tempLinkedFeatures = linkedFeatures

    tradeTokenCounts = {}
    for _, tradeGoodType in ipairs(TRADE_GOOD_TYPES) do
        tradeTokenCounts[tradeGoodType] = {}
    end
    if controlPanelSettings['TnBTradeGoods'] then
        for _, player in ipairs(activePlayers) do
            local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
            for _, obj in ipairs(playerPossessions) do
                local tokenName = obj.getVar('tokenName')
                if table.contains(TRADE_GOOD_TYPES, tokenName) then
                    local quantity = obj.getQuantity()
                    if quantity == -1 then quantity = 1 end
                    if tradeTokenCounts[tokenName][player] == nil then
                        tradeTokenCounts[tokenName][player] = quantity
                    else
                        tradeTokenCounts[tokenName][player] = tradeTokenCounts[tokenName][player] + quantity
                    end
                end
            end
        end
    end

    AICalculateActiveScoresEasy()

    baselineScores = {}
    --debugMessage(1, "baseline scores:")
    for _, player in ipairs(activePlayers) do
        baselineScores[player] = activeScores[player]
        --debugMessage(1, " " .. player .. ": " .. baselineScores[player])
    end
end

function AICalculateLocationScoreEasy(newTile, tileRotation, xIndex, zIndex)
    --debugMessage(1, "AICalculateLocationScore at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
    --temporarily insert this tile into the grid
    addTile(xIndex, zIndex, newTile, tileRotation, true)
    joinedActiveFigures = {}
    for featureNum, figureList in pairs(activeFigures) do
        if tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end
        if joinedActiveFigures[featureNum] == nil then
            joinedActiveFigures[featureNum] = {}
            joinedActiveFigures[featureNum].followers = {}
            joinedActiveFigures[featureNum].specialFigures = {}
        end
        for _, follower in ipairs(figureList.followers) do
            local followerXIndex, followerZIndex, _, _ = getFigureTileLocation(follower)
            table.insert(joinedActiveFigures[featureNum].followers, {figureName=follower.getVar('figureName'), owner=follower.getVar('owner'), tile_guid=tileGrid[followerXIndex][followerZIndex].tile_guid})
        end
        for _, figure in ipairs(figureList.specialFigures) do
            table.insert(joinedActiveFigures[featureNum].specialFigures, {figureName=figure.getVar('figureName'), owner=figure.getVar('owner')})
        end
    end
    AICalculateActiveScoresEasy(xIndex, zIndex)
    local scoreChange = {}
    local spareFollowerCounts = {}
    local moveScore = 0
    for _, player in ipairs(activePlayers) do
        scoreChange[player] = activeScores[player] - baselineScores[player]
        spareFollowerCounts[player] = followerCountChange[player] + baselineFollowerCounts[player]
        --debugMessage(1, player .. " score of " .. baselineScores[player] .. " changed to " .. activeScores[player] .. " difference of " .. scoreChange[player])
        --debugMessage(1, player .. " spare followers: " .. baselineFollowerCounts[player] .. " changed to " .. spareFollowerCounts[player] .. " difference of " .. followerCountChange[player])
    end
    for _, player in ipairs(activePlayers) do
        if player == activePlayers[currentPlayer] then
            moveScore = moveScore + scoreChange[player] + followerCountChange[player] * USED_FOLLOWER_PENALTY_EASY
            --debugMessage(1, "score change of " .. scoreChange[player] .. " follower adjusted by " .. followerCountChange[player] * USED_FOLLOWER_PENALTY_EASY .. " final move score: " .. moveScore)
        elseif #activePlayers <= 2 then
            moveScore = moveScore - scoreChange[player] - followerCountChange[player] * USED_FOLLOWER_PENALTY_EASY
        elseif activeScores[activePlayers[currentPlayer]] - activeScores[player] < SCORE_THREAT_THRESHOLD then
            -- if this opponent is SCORE_THREAT_THRESHOLD points behind (after this move), then we don't care about their score change
            moveScore = moveScore - (scoreChange[player] * (SCORE_THREAT_THRESHOLD - (activeScores[activePlayers[currentPlayer]] + followerCountChange[player] * USED_FOLLOWER_PENALTY_EASY) + activeScores[player]) / SCORE_THREAT_THRESHOLD) / (#activePlayers - 1)
            --debugMessage(1, player .. ":subtract score of " .. scoreChange[player] * (SCORE_THREAT_THRESHOLD - (activeScores[activePlayers[currentPlayer]] + followerCountChange[player] * USED_FOLLOWER_PENALTY_EASY)) .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        end
    end

    local highestUnusedFeature = 0
    local spareFollowerAdjustment = (-7 * USED_FOLLOWER_PENALTY_EASY) + (spareFollowerCounts[activePlayers[currentPlayer]] * USED_FOLLOWER_PENALTY_EASY)

    local featureVisited = { }
    local positionsToVisit = { }

    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for specialFeatureNum, feature in ipairs(specialFeatures) do
            if feature[3] ~= nil then
                table.insert(positionsToVisit, specialFeatureNum+12)
            end
        end
    end
    for tilePosition=1, 12 do
        table.insert(positionsToVisit, tilePosition)
    end

    for _, tilePosition in ipairs(positionsToVisit) do
        local featureMapPosition = tilePositionToFeatureMapPosition(tilePosition, tileRotation)
        local featureNum = getFeatureNumAt(xIndex, zIndex, featureMapPosition)
        if featureNum ~= nil and tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end

        if featureNum ~= nil and featureVisited[featureNum] ~= true then
            local featureFigures = joinedActiveFigures[featureNum]
            if featureFigures == nil then
                featureFigures = {}
                featureFigures.followers = {}
                featureFigures.specialFigures = {}
            end
            local featureScore, numOpenings, nameOfFeature = AICalculateFeatureScoreEasy(featureNum, featureFigures)
            local score

            if numRemainingMoves + 1 > spareFollowerCounts[activePlayers[currentPlayer]] and (numOpenings > 0 or nameOfFeature == 'Field') then
                score = featureScore + moveScore + spareFollowerAdjustment
                if nameOfFeature ~= 'Field' and nameOfFeature ~= 'Cloister' then
                    score = score - numOpenings * OPEN_FEATURE_PENALTY
                elseif nameOfFeature == 'Cloister' then
                    --TODO: I think cloister needs a slight penalty
                end
            else
                score = featureScore + moveScore
            end

            local usedFeature = false
            local playerHasFollower = false
            for _, follower in ipairs(featureFigures.followers) do
                if follower.owner == activePlayers[currentPlayer] and table.contains(FOLLOWER_TYPES, follower.figureName) then
                    playerHasFollower = true
                end
            end
            if #featureFigures.followers == 0 and
                not (nameOfFeature == 'Road' and controlPanelSettings['BaseDisableRoads']) and
                not (nameOfFeature == 'City' and controlPanelSettings['BaseDisableCities']) and
                not (nameOfFeature == 'Cloister' and controlPanelSettings['BaseDisableCloisters']) and
                not (nameOfFeature == 'Field' and controlPanelSettings['BaseDisableFarms']) then
                local fieldHasBarn = false
                if (nameOfFeature == 'Field' and #featureFigures.specialFigures > 0) then
                    for _, figure in ipairs(featureFigures.specialFigures) do
                        if figure.figureName == 'Barn' then
                            fieldHasBarn = true
                        end
                    end
                end
                if not fieldHasBarn and (baselineFollowerCounts[activePlayers[currentPlayer]] > 0 or baselineFigures[activePlayers[currentPlayer]]['Big Follower']) and (numRemainingMoves + 1 <= spareFollowerCounts[activePlayers[currentPlayer]] or (featureScore + spareFollowerAdjustment > FOLLOWER_SCORE_THRESHOLD or numOpenings == 0)) then
                    if score == highestScore then
                        --debugMessage(1, "found identical meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                        numIdenticalScore = numIdenticalScore + 1
                    end
                    if score > highestScore or (math.random(numIdenticalScore) == 1 and score == highestScore) then -- this is to lessen the bias towards one side of the play area
                        --debugMessage(1, "found new best meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                        --debugMessage(1, "moveScore:".. moveScore .. " spareFollowerAdjustment:" .. spareFollowerAdjustment .. " openFeaturePenalty:" .. numOpenings * OPEN_FEATURE_PENALTY .. " featureScore:" .. featureScore)
                        if score > highestScore then
                            numIdenticalScore = 1
                        end
                        highestScore = score
                        highestScoreX = xIndex
                        highestScoreZ = zIndex
                        highestScoreRot = tileRotation
                        highestScorePos = featureMapPosition
                        if baselineFigures[activePlayers[currentPlayer]]['Big Follower'] and (baselineFollowerCounts[activePlayers[currentPlayer]] == 0 or nameOfFeature == 'City') then
                            highestScoreFigure = 'Big Follower'
                        else
                            highestScoreFigure = 'Follower'
                        end
                        usedFeature = true
                    end
                end
                if not usedFeature and nameOfFeature ~= 'Field' and nameOfFeature ~= 'Cloister' then
                    highestUnusedFeature = featureScore
                end
            elseif playerHasFollower and nameOfFeature == 'Field' and baselineFigures[activePlayers[currentPlayer]]['Pig'] then
                score = featureScore / 3
                if score == highestScore then
                    --debugMessage(1, "found identical pig score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                    numIdenticalScore = numIdenticalScore + 1
                end
                if score > highestScore or (math.random(numIdenticalScore) == 1 and score == highestScore) then -- this is to lessen the bias towards one side of the play area
                    --debugMessage(1, "found new best pig score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                    if score > highestScore then
                        numIdenticalScore = 1
                    end
                    highestScore = score
                    highestScoreX = xIndex
                    highestScoreZ = zIndex
                    highestScoreRot = tileRotation
                    highestScorePos = featureMapPosition
                    highestScoreFigure = 'Pig'
                    usedFeature = true
                end
            elseif playerHasFollower and numOpenings > 0 and (nameOfFeature == 'City' or nameOfFeature == 'Road') and baselineFigures[activePlayers[currentPlayer]]['Builder'] then
                local builderScore = moveScore + 0.01 --give a small bonus so it is more likely to be used in tie situations
                if builderScore == highestScore then
                    --debugMessage(1, "found identical builder score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                    numIdenticalScore = numIdenticalScore + 1
                end
                if builderScore > highestScore or (math.random(numIdenticalScore) == 1 and builderScore == highestScore) then -- this is to lessen the bias towards one side of the play area
                    --debugMessage(1, "found new best builder score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                    if builderScore > highestScore then
                        numIdenticalScore = 1
                    end
                    highestScore = builderScore
                    highestScoreX = xIndex
                    highestScoreZ = zIndex
                    highestScoreRot = tileRotation
                    highestScorePos = featureMapPosition
                    highestScoreFigure = 'Builder'
                    usedFeature = true
                end
            end
            if nameOfFeature == 'Field' and numOpenings > 0 and baselineFigures[activePlayers[currentPlayer]]['Shepherd'] then
                local hasShepherd = false
                for _, specialFigure in ipairs(featureFigures.specialFigures) do
                    if specialFigure.figureName == "Shepherd" then
                        hasShepherd = true
                    end
                end
                if not hasShepherd then
                    local shepherdScore = moveScore + 2
                    if shepherdScore == highestScore then
                        --debugMessage(1, "found identical shepherd score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                        numIdenticalScore = numIdenticalScore + 1
                    end
                    --debugMessage(1, "shepherdScore at feature " .. featureNum .. ":" .. shepherdScore)
                    if shepherdScore > highestScore or (math.random(numIdenticalScore) == 1 and shepherdScore == highestScore) then -- this is to lessen the bias towards one side of the play area
                        --debugMessage(1, "found new best shepherd score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                        if shepherdScore > highestScore then
                            numIdenticalScore = 1
                        end
                        highestScore = shepherdScore
                        highestScoreX = xIndex
                        highestScoreZ = zIndex
                        highestScoreRot = tileRotation
                        highestScorePos = featureMapPosition
                        highestScoreFigure = 'Shepherd'
                        usedFeature = true
                    end
                end
            end
            featureVisited[featureNum] = true
        end
    end
    moveScore = moveScore - highestUnusedFeature * 0.02 -- meant to slightly disourage from building a feature for someone else to take
    if moveScore == highestScore then
        --debugMessage(1, "found identical tile score: " .. moveScore .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        numIdenticalScore = numIdenticalScore + 1
    end
    if moveScore > highestScore or (math.random(numIdenticalScore) == 1 and moveScore == highestScore) then -- this is to lessen the bias towards one side of the play area
        --debugMessage(1, "found new best tile score: " .. moveScore .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        if moveScore > highestScore then
            numIdenticalScore = 1
        end
        highestScore = moveScore
        highestScoreX = xIndex
        highestScoreZ = zIndex
        highestScoreRot = tileRotation
        highestScorePos = nil
        highestScoreFigure = nil
    end

    tileGrid[xIndex][zIndex] = nil
end

function AICalculateActiveScoresEasy(newXIndex, newZIndex)
    --debugMessage(2, "AI checking current active scores..")
    if os.clock() - lastFrameTime > FRAME_TIME then
        lastFrameTime = lastFrameTime + FRAME_TIME
        coroutine.yield(0)
    end
    activeScores = {}
    followerCountChange = {}
    for _, player in ipairs(activePlayers) do
        local scoreCounter = getObjectFromGUID(score_counter_guids[player])
        if scoreCounter ~= nil then
            activeScores[player] = getObjectFromGUID(score_counter_guids[player]).Counter.getValue()
        else
            activeScores[player] = 0
        end
        followerCountChange[player] = 0
    end

    if newXIndex ~= nil and (controlPanelSettings['TnBTradeGoods'] or controlPanelSettings['TnBBuilder'] or controlPanelSettings['HnSShepherd']) then
        local specialFeatures = {}

        for featureNum, feature in pairs(tempFeatureList) do
            if feature.numOpenings == 0 and feature.nameOfFeature == 'City' then
                for _, specialFeature in ipairs(feature.specialFeatures) do
                    if table.contains(TRADE_GOOD_TYPES, specialFeature) then
                        table.insert(specialFeatures, specialFeature)
                    end
                end
            end
            if joinedActiveFigures[featureNum] ~= nil then
                if feature.nameOfFeature == 'City' or feature.nameOfFeature == 'Road' then
                    for _, specialFigure in ipairs(joinedActiveFigures[featureNum].specialFigures) do
                        if specialFigure.owner == activePlayers[currentPlayer] then --do not give sheep/extra builder tile (CAR ref 149)
                            if specialFigure.figureName == 'Builder' and not hasAlreadyTakenBuilderTile then
                                activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + BUILDER_EXTRA_TURN_VALUE
                            end
                        end
                    end
                elseif feature.nameOfFeature == 'Field' then
                    for _, specialFigure in ipairs(joinedActiveFigures[featureNum].specialFigures) do
                        if specialFigure.owner == activePlayers[currentPlayer] then --do not give give sheep/extra builder tile (CAR ref 149)
                            if specialFigure.figureName == 'Shepherd' then
                                activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + SHEPHERD_EXTEND_VALUE
                            end
                        end
                    end
                end
            end
        end

        if controlPanelSettings['TnBTradeGoods'] then
            for _, specialFeature in ipairs(specialFeatures) do
                local highestNumTokens = 0
                local secondHighestTokens = 0
                local numRemainingTokens = TRADE_TOKEN_COUNTS[specialFeature]
                local tradeTokenCounts = {}
                tradeTokenCounts[activePlayers[currentPlayer]] = 0
                --find the highest count for this token
                for _, player in ipairs(activePlayers) do
                    local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
                    local playerNumTokens = 0
                    for _, obj in ipairs(playerPossessions) do
                        if obj.getVar('tokenName') == specialFeature then
                            local quantity = obj.getQuantity()
                            if quantity == -1 then quantity = 1 end
                            if tradeTokenCounts[player] == nil then
                                tradeTokenCounts[player] = quantity
                            else
                                tradeTokenCounts[player] = tradeTokenCounts[player] + quantity
                            end
                            numRemainingTokens = numRemainingTokens - quantity
                        end
                    end
                    if tradeTokenCounts[player] ~= nil and tradeTokenCounts[player] >= highestNumTokens then
                        secondHighestTokens = highestNumTokens
                        highestNumTokens = tradeTokenCounts[player]
                    end
                end
                --basically, tokens are only worth something if:
                --you are first place and second place has enough tokens to catch up
                --or you are not first place, but have enough tokens left to catch up
                if (tradeTokenCounts[activePlayers[currentPlayer]] == highestNumTokens and highestNumTokens - secondHighestTokens <= numRemainingTokens) or
                (tradeTokenCounts[activePlayers[currentPlayer]] ~= highestNumTokens and highestNumTokens - tradeTokenCounts[activePlayers[currentPlayer]] <= numRemainingTokens) then
                    if #activePlayers > 1 then
                        activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + ((10 + (10 / (#activePlayers - 1))) / numRemainingTokens)
                    else
                        activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + 20
                    end
                end
            end
        end
    end
    for featureNum, featureFigures in pairs(joinedActiveFigures) do
        local score, numOpenings, nameOfFeature = AICalculateFeatureScoreEasy(featureNum, featureFigures)
        local followerCounts = {}
        local hasHill = {}
        local hasMayor = {}
        local topWeight = -1
        --find the relative weights for the followers on this feature
        for _, follower in ipairs(featureFigures.followers) do
            if numOpenings == 0 and nameOfFeature ~= 'Field' then
                followerCountChange[follower.owner] = followerCountChange[follower.owner] + 1
            end
            local weight = 0
            if follower.figureName == 'Follower' or follower.figureName == 'Wagon' or follower.figureName == 'Abbot' then weight = 1
            elseif follower.figureName == 'Big Follower' then weight = 2
            elseif follower.figureName == 'Mayor' then
                for _, specialFeature in ipairs(traversedSpecialFeatures) do
                    if specialFeature == 'Pennant' then weight = weight + 1 end
                end
                hasMayor[follower.owner] = true
            end
            if weight > 0 then
                local specialFeatures = getObjectFromGUID(follower.tile_guid).getTable('specialFeatures')
                if controlPanelSettings['HnSHills'] and specialFeatures ~= nil then
                    for _, specialFeature in ipairs(specialFeatures) do
                        if specialFeature[1] == "Hill" then
                            --although it would have been easier to just add 0.001 to the weight here, it would have technically violated the rules, since multiple hills are not supposed to give extra weight.
                            hasHill[follower.owner] = true
                        end
                    end
                end
            end
            if followerCounts[follower.owner] == nil then
                followerCounts[follower.owner] = weight
            else
                followerCounts[follower.owner] = followerCounts[follower.owner] + weight
            end
        end
        --add hill weight if there is a hill, find top weight for the feature
        for player, value in pairs(followerCounts) do
            if hasHill[player] then
                --if the follower is on a hill, add a small value to it to break any ties
                followerCounts[player] = followerCounts[player] + 0.001
            end
            if followerCounts[player] > topWeight then topWeight = followerCounts[player] end
        end
        -- local eligibleFollowers = fairyEligibleFollowers()
        -- for _, eligibleFollower in ipairs(eligibleFollowers) do
        --     if eligibleFollower == follower then
        --         allGameMessage({"MESSAGE_SCORE_FAIRY_FINISH", {'{c1}', eligibleFollower.getDescription()}, {'{f1}', eligibleFollower.getName()}}, player_color_tints[eligibleFollower.getVar('owner')])
        --         scorePoints(eligibleFollower.owner, 'Fairy', 3)
        --     end
        -- end
        -- if follower.figureName == "Wagon" then
        --     wagonLocations[follower.owner] = {}
        --     wagonLocations[follower.owner].x = follower.getPosition().x
        --     wagonLocations[follower.owner].z = follower.getPosition().z
        --     hasAvailableWagonFeature[follower.owner] = hasIncompleteSecondaryFeature
        -- end
        -- local winner = false
        for player, value in pairs(followerCounts) do
            if (topWeight > 0 and value >= topWeight) then
                activeScores[player] = activeScores[player] + score
            end
        end
    end
end

function AICalculateFeatureScoreEasy(featureNum, figures)
    --debugMessage(3, "AICalculateFeatureScore")
    local feature = tempFeatureList[featureNum]
    if feature == nil then feature = featureList[featureNum] end

    local nameOfFeature = feature.nameOfFeature
    local specialFeatures = feature.specialFeatures
    local numOpenings = feature.numOpenings
    local numTiles = feature.numTiles
    if nameOfFeature == 'River' or nameOfFeature == 'Carcassonne' then
        return -1000, numOpenings, nameOfFeature
    end

    local featureComplete
    if numOpenings == 0 then
        featureComplete = true
    else
        featureComplete = false
    end

    local hasPig = {}
    --local hasBarn = false
    --local hasNewBarn = false
    for _, figure in ipairs(figures.specialFigures) do
        if figure.figureName == 'Pig' then hasPig[figure.owner] = true end
        -- if figure.figureName == 'Barn' then
        --     hasBarn = true
        --     if newBarn ~= nil and figure.getGUID() == newBarn then
        --         hasNewBarn = true
        --         newBarn = nil
        --     end
        --     --recalculate "follower count" with only barns. Technically they aren't followers but it was easier in code.
        --     if #traversedFollowers == 0 then
        --         if followerCounts[figure.owner] == nil then
        --             followerCounts[figure.owner] = 1
        --         else
        --             followerCounts[figure.owner] = followerCounts[figure.owner] + 1
        --         end
        --         if followerCounts[figure.owner] > topWeight then topWeight = followerCounts[figure.owner] end
        --     end
        -- end
    end
    local score = 0
    local containsPigHerd = false
    if nameOfFeature == 'City' and not controlPanelSettings['BaseDisableCities'] then
        score = numTiles
        local containsCathedral = false
        for _, feature in ipairs(specialFeatures) do
            if feature == 'Pennant' then
                score = score + 1
            elseif table.contains(TRADE_GOOD_TYPES, feature) and numOpenings > 0 then
                score = score + UNFINISHED_TRADE_TOKEN_VALUE
            end
            if feature == 'Cathedral' and controlPanelSettings['InCCathedrals'] then
                containsCathedral = true
            end
        end
        if containsCathedral then
            if featureComplete then
                --in order to get the AI to prioritize city pieces, we need to inflate the incomplete value to be partway between the complete value
                --however, this creates a lower score difference between a completed city and an incomplete one. In order to make sure that the AI still
                --tries to finish the city, we give it a small bonus (roughly equal to the complete score minus the incomplete score)
                local bonus = score * 3 - (score * 3 * numRemainingMoves / END_GAME_TRANSITION)
                score = score * 3
                score = score + bonus
            else
                if numRemainingMoves > END_GAME_TRANSITION then
                    score = score * 2.4
                else
                    if numRemainingMoves / END_GAME_TRANSITION > 1 / (numOpenings + 1) then
                        score = score * 3 * numRemainingMoves / END_GAME_TRANSITION
                    else
                        score = score * 3 / (numOpenings + 1)
                    end
                end
            end
        else
            if featureComplete then
                --in order to get the AI to prioritize city pieces, we need to inflate the incomplete value to be partway between the complete value
                --however, this creates a lower score difference between a completed city and an incomplete one. In order to make sure that the AI still
                --tries to finish the city, we give it a small bonus (roughly equal to the complete score minus the incomplete score)
                local bonus
                if numRemainingMoves > END_GAME_TRANSITION then
                    bonus = score * 0.4
                else
                    bonus = score - (score * 0.6 * numRemainingMoves / END_GAME_TRANSITION)
                end
                score = score * 2
                score = score + bonus
            else
                if numRemainingMoves > END_GAME_TRANSITION then
                    score = score * 1.6
                else
                    score = score + score * 0.6 * numRemainingMoves / END_GAME_TRANSITION
                end
            end
        end

        if lastPlacedTileX ~= nil then --TODO: This broke something when lastPlacedTileX was null. Is lastPlacedTileX even used when checking possible moves? Wrapping in this if statement for now as a temporary fix
            local tileFeatures = tileGrid[lastPlacedTileX][lastPlacedTileZ].tileFeatures
            local isAbbey = false
            if tileFeatures ~= nil then
                for _, tileFeature in ipairs(tileFeatures) do
                    if tileFeature == 'Abbey' then
                        isAbbey = true
                    end
                end
            end
            --do not nerf cities that were completed by an abbey, or incomplete cities
            if not isAbbey and featureComplete and controlPanelSettings['BaseNerfSmallCity'] and score == 4 then
                score = 2
            end
        end
    elseif nameOfFeature == 'Field' and not controlPanelSettings['BaseDisableFarms'] then
        local numCities = 0

        local linkedCities = tempLinkedFeatures['City-Field'][featureNum]
        if linkedCities == nil then linkedCities = linkedFeatures['City-Field'][featureNum] end
        if linkedCities ~= nil then
            for connectedFeatureNum, _ in pairs(linkedCities) do
                local numOpenings
                if tempFeatureList[connectedFeatureNum] ~= nil then
                    numOpenings = tempFeatureList[connectedFeatureNum].numOpenings
                else
                    numOpenings = featureList[connectedFeatureNum].numOpenings
                end
                if numOpenings == 0 then
                    numCities = numCities + 1
                end
            end
        end
        for _, feature in ipairs(specialFeatures) do
            -- if feature == 'Completed City' then
            --     numCities = numCities + 1
            -- end
            if feature == 'Pig-herd' and not controlPanelSettings['RIIDisablePigherd'] then
                containsPigHerd = true
            end
        end
        featureComplete = false --so that this feature won't be scored before the end of the game
        local scoreMultiplier = 3
        -- if hasBarn then
        --     if #traversedFollowers > 0 then
        --         if not hasNewBarn then
        --             scoreMultiplier = 1
        --         end
        --     else
        --         scoreMultiplier = 4
        --     end
        -- end
        if hasPig[player] ~= nil then
            scoreMultiplier = scoreMultiplier + 1
        end
        if containsPigHerd and #figures.followers > 0 then -- CAR pg 67 ref 194
            scoreMultiplier = scoreMultiplier + 1
        end
        if numRemainingMoves > END_GAME_TRANSITION * 2.0 then
            scoreMultiplier = scoreMultiplier - 2.0
        else
            scoreMultiplier = scoreMultiplier - (numRemainingMoves / END_GAME_TRANSITION)
        end
        score = (numCities * scoreMultiplier)
        if numRemainingMoves > END_GAME_TRANSITION then
            score = score - FIELD_PENALTY
        end
    elseif nameOfFeature == 'Road' and not controlPanelSettings['BaseDisableRoads'] then
        score = numTiles
        local containsInn = false
        for _, feature in ipairs(specialFeatures) do
            if feature == 'Inn' and controlPanelSettings['InCInns'] then
                containsInn = true
            end
        end
        if containsInn then
            if featureComplete then
                score = score * 2
            else
                if numRemainingMoves > END_GAME_TRANSITION then
                    score = score * 2
                else
                    if numRemainingMoves / END_GAME_TRANSITION > 1 / (numOpenings + 1) then
                        score = score * 2 * numRemainingMoves / END_GAME_TRANSITION
                    else
                        score = score * 2 / (numOpenings + 1)
                    end
                end
            end
        end
    elseif table.contains(CLOISTER_FEATURES, nameOfFeature) and not controlPanelSettings['BaseDisableCloisters'] then
        score = 1
        for x=-1, 1 do
            for z=-1, 1 do
                if not (x == 0 and z == 0) and tileGridOccupied(feature.featureLocation.x + x, feature.featureLocation.z + z) then
                    score = score + 1
                    if controlPanelSettings['HnSVineyards'] then
                        local specialFeatures = getObjectFromGUID(tileGrid[feature.featureLocation.x + x][feature.featureLocation.z + z].tile_guid).getTable('specialFeatures')
                        if specialFeatures ~= nil then
                            for _, feature in ipairs(specialFeatures) do
                                if feature == 'Vineyard' then
                                    if featureComplete then
                                        score = score + 3
                                    else
                                        if numRemainingMoves > END_GAME_TRANSITION then
                                            score = score + 3
                                        else
                                            if numRemainingMoves / END_GAME_TRANSITION > 1 / numOpenings then
                                                score = score + 3 * numRemainingMoves / END_GAME_TRANSITION
                                            else
                                                score = score + 3 / numOpenings
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        numOpenings = 9 - score
    end
    return score, numOpenings, nameOfFeature
end

--get the base score at the beginning of the turn
function AICalculateBaselineScores()
    --debugMessage(1, "AICalculateBaselineScores")
    highestScore = -999
    highestScoreX = nil
    highestScoreZ = nil
    highestScoreRot = nil
    highestScorePos = nil
    highestScoreFigure = nil
    numIdenticalScore = 1

    tempLinkedFeatures = {['City-Field'] = {}, ['Road Intersection'] = {}}
    tempValidTileLocations = {}
    tempTileConnectionOdds = {}
    tempFeatureIndex = featureIndex
    tempFeatureList = {}
    tempJoinedFeature = {}

    getActiveFigures()
    getActiveNeutralFigures()

    --since we haven't joined any features yet, the currently active figures can be used
    joinedActiveFigures = {}
    for featureNum, figureList in pairs(activeFigures) do
        if joinedActiveFigures[featureNum] == nil then
            joinedActiveFigures[featureNum] = {}
            joinedActiveFigures[featureNum].followers = {}
            joinedActiveFigures[featureNum].specialFigures = {}
        end

        for _, follower in ipairs(figureList.followers) do
            local followerXIndex, followerZIndex, _, _ = getFigureTileLocation(follower)
            table.insert(joinedActiveFigures[featureNum].followers, {figureName=follower.getVar('figureName'), owner=follower.getVar('owner'), tile_guid=tileGrid[followerXIndex][followerZIndex].tile_guid})
        end
        for _, figure in ipairs(figureList.specialFigures) do
            table.insert(joinedActiveFigures[featureNum].specialFigures, {figureName=figure.getVar('figureName'), owner=figure.getVar('owner')})
        end
    end

    --FIXME: I don't like that we're assuming the number of tokens and value will never change, but currently it's only possible to get
    --the script data of objects in a container if the container is a deck. I could get around this by using the name and description, but
    --localization would then be a problem. Perhaps hack around this later.
    local totalValue = 37 --total value of all sheep tokens combined
    local numTokens = 18 --total number of sheep and wolf tokens
    joinedActiveNeutralFigures = {}
    for featureNum, figureList in pairs(activeNeutralFigures) do
        if joinedActiveNeutralFigures[featureNum] == nil then
            joinedActiveNeutralFigures[featureNum] = {}
            joinedActiveNeutralFigures[featureNum].sheepTokens = {}
        end
        for _, sheepToken in ipairs(figureList.sheepTokens) do
            if sheepToken.getVar('tokenName') == 'Sheep' then
                totalValue = totalValue - sheepToken.getVar('count')
            -- elseif sheepToken.getVar('tokenName') == 'Wolf' then
            --     totalValue = totalValue - ???
            end
            numTokens = numTokens - 1
            table.insert(joinedActiveNeutralFigures[featureNum].sheepTokens, {tokenName=sheepToken.getVar('tokenName'), count=sheepToken.getVar('count')})
        end
    end
    newShepherdValue = totalValue / numTokens
    --tempFeatureList = featureList
    --tempLinkedFeatures = linkedFeatures

    AICalculateFeatureJoinPercentages()

    tradeTokenCounts = {}
    blockedTokens = {}
    for _, tradeGoodType in ipairs(TRADE_GOOD_TYPES) do
        tradeTokenCounts[tradeGoodType] = {}
        blockedTokens[tradeGoodType] = 0
        for _, player in ipairs(activePlayers) do
            tradeTokenCounts[tradeGoodType][player] = 0
        end
    end
    if controlPanelSettings['TnBTradeGoods'] then
        for _, player in ipairs(activePlayers) do
            local playerPossessions = getObjectFromGUID(playerPossessionScriptingZones[player]).getObjects()
            for _, obj in ipairs(playerPossessions) do
                local tokenName = obj.getVar('tokenName')
                if table.contains(TRADE_GOOD_TYPES, tokenName) then
                    local quantity = obj.getQuantity()
                    if quantity == -1 then quantity = 1 end
                    tradeTokenCounts[tokenName][player] = tradeTokenCounts[tokenName][player] + quantity
                end
            end
        end
        local numCards
        if NUMBER_OF_DRAWN_TILES_FOR_BLOCK_PERCENTAGE < numRemainingMoves then
            numCards = NUMBER_OF_DRAWN_TILES_FOR_BLOCK_PERCENTAGE
        else
            numCards = numRemainingMoves
        end
        for featureNum, feature in pairs(featureList) do
            if feature.numOpenings > 0 and feature.nameOfFeature == 'City' then
                local containsToken = false
                for _, specialFeature in ipairs(feature.specialFeatures) do
                    if table.contains(TRADE_GOOD_TYPES, specialFeature) then
                        containsToken = true
                        break
                    end
                end
                if containsToken then
                    local blockPercentage
                    if featureBlockPercentages["" .. featureNum] ~= nil then
                        blockPercentage = featureBlockPercentages["" .. featureNum]
                    else
                        blockPercentage = 0
                        for openingCoord, _ in pairs(feature.openingCoords) do
                            local connectionOdds = tileConnectionOdds[openingCoord]
                            if connectionOdds ~= nil then --if it is still nil, this is probably a "proximity feature" that doesn't have neighbors yet
                                if connectionOdds["blocked"] > tilesRemaining or tilesRemaining == 0 then
                                    blockPercentage = 1
                                else
                                    blockPercentage = 1 - ((1 - blockPercentage) * (1 - (connectionOdds["blocked"] / tilesRemaining) ^ numCards))
                                end
                            end
                        end
                    end
                    for _, specialFeature in ipairs(feature.specialFeatures) do
                        if table.contains(TRADE_GOOD_TYPES, specialFeature) then
                            blockedTokens[specialFeature] = blockedTokens[specialFeature] + blockPercentage
                        end
                    end
                end
            end
        end
    end

    AICalculateActiveScores()

    baselineScores = {}
    -- debugMessage(1, "baseline scores:")
    for _, player in ipairs(activePlayers) do
        baselineScores[player] = activeScores[player]
        -- debugMessage(1, " " .. player .. ": " .. baselineScores[player])
    end
    -- print("baseline finished")
end

--calculate the gain in value from placing the tile here, in addition to possibly using a figure
function AICalculateTileLocationScore(newTile, tileRotation, xIndex, zIndex)
    debugMessage(1, "AICalculateTileLocationScore at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)

    --temporarily insert this tile into the grid
    addTile(xIndex, zIndex, newTile, tileRotation, true)

    --recreate joinedActiveFigures. If a featureNum has changed as a result of adding the tile, the figure's featureNum should be updated too
    joinedActiveFigures = {}
    for featureNum, figureList in pairs(activeFigures) do
        if tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end
        if joinedActiveFigures[featureNum] == nil then
            joinedActiveFigures[featureNum] = {}
            joinedActiveFigures[featureNum].followers = {}
            joinedActiveFigures[featureNum].specialFigures = {}
        end

        for _, follower in ipairs(figureList.followers) do
            local followerXIndex, followerZIndex, _, _ = getFigureTileLocation(follower)
            table.insert(joinedActiveFigures[featureNum].followers, {figureName=follower.getVar('figureName'), owner=follower.getVar('owner'), tile_guid=tileGrid[followerXIndex][followerZIndex].tile_guid})
        end
        for _, figure in ipairs(figureList.specialFigures) do
            table.insert(joinedActiveFigures[featureNum].specialFigures, {figureName=figure.getVar('figureName'), owner=figure.getVar('owner')})
        end
    end
    --recreate joinedActiveNeutralFigures. If a featureNum has changed as a result of adding the tile, the figure's featureNum should be updated too
    joinedActiveNeutralFigures = {}
    for featureNum, figureList in pairs(activeNeutralFigures) do
        if tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end
        if joinedActiveNeutralFigures[featureNum] == nil then
            joinedActiveNeutralFigures[featureNum] = {}
            joinedActiveNeutralFigures[featureNum].sheepTokens = {}
        end
        for _, sheepToken in ipairs(figureList.sheepTokens) do
            table.insert(joinedActiveNeutralFigures[featureNum].sheepTokens, {tokenName=sheepToken.getVar('tokenName'), count=sheepToken.getVar('count')})
        end
    end
    AICalculateFeatureJoinPercentages()
    AICalculateActiveScores(xIndex, zIndex, tileRotation)
    local moveScore = AICalculateCurrentPlayerScoreBenefit()
    debugMessage(1, "moveScore:" .. moveScore)

    local currentPlayerSpareFollowers = currentPlayerFollowerCountChange + baselineFollowerCounts[activePlayers[currentPlayer]] + (baselineFigures[activePlayers[currentPlayer]]['Big Follower'] and 1 or 0)

    local highestUnusedFeature = 0
    local spareFollowerAdjustment
    if numRemainingMoves + 1 <= currentPlayerSpareFollowers then
        spareFollowerAdjustment = 0
    elseif currentPlayerSpareFollowers > 1 then
        spareFollowerAdjustment = (-7 * USED_FOLLOWER_PENALTY_HARD) + (currentPlayerSpareFollowers * USED_FOLLOWER_PENALTY_HARD) - FOLLOWER_SCORE_THRESHOLD
    else
        spareFollowerAdjustment = -USED_LAST_FOLLOWER_PENALTY
    end

    local featureVisited = { }
    local positionsToVisit = { }

    local specialFeatures = newTile.getTable('specialFeatures')
    if specialFeatures ~= nil then
        for i, feature in ipairs(specialFeatures) do
            if feature[3] ~= nil then
                table.insert(positionsToVisit, i+12)
            end
        end
    end
    for i=1, 12 do
        table.insert(positionsToVisit, i)
    end

    for _, tilePosition in ipairs(positionsToVisit) do
        local featureMapPosition = tilePositionToFeatureMapPosition(tilePosition, tileRotation)
        local featureNum = getFeatureNumAt(xIndex, zIndex, featureMapPosition)
        if featureNum ~= nil and tempJoinedFeature[featureNum] ~= nil then
            featureNum = tempJoinedFeature[featureNum]
        end

        if featureNum ~= nil and featureVisited[featureNum] ~= true then
            local tempFeatureJoinPercentages = table.shallow_copy(featureJoinPercentages)
            local tempFeatureBlockPercentages = table.shallow_copy(featureBlockPercentages)
            local featureNumKey = "" .. featureNum
            if joinedActiveFigures[featureNum] == nil then
                local traversedOpenings = {}
                local feature = tempFeatureList[featureNum]
                if feature == nil then feature = featureList[featureNum] end
                local openingCoords = table.shallow_copy(feature.openingCoords)
                featureJoinPercentages[featureNumKey] = {}
                featureJoinPercentages[featureNumKey].percentage = 1
                featureJoinPercentages[featureNumKey].openings = {}

                AICalculateFeatureJoinPercentage(traversedOpenings, {featureNum}, featureNumKey, openingCoords, featureJoinPercentages, 1, featureBlockPercentages)
            end
            local featureFigures = joinedActiveFigures[featureNum]
            if featureFigures == nil then
                featureFigures = {}
                featureFigures.followers = {}
                featureFigures.specialFigures = {}
            end
            if joinedActiveNeutralFigures[featureNum] == nil then
                featureFigures.sheepTokens = {}
            else
                featureFigures.sheepTokens = joinedActiveNeutralFigures[featureNum].sheepTokens
            end

            traversedOpenings = {}

            local feature = tempFeatureList[featureNum]
            if feature == nil then feature = featureList[featureNum] end

            local nameOfFeature = feature.nameOfFeature
            local specialFeatures = feature.specialFeatures
            local numOpenings = feature.numOpenings
            local openingCoords = feature.openingCoords
            local numTiles = feature.numTiles
            local featureLocation = feature.featureLocation

            local playerHasFollower = false
            for _, follower in ipairs(featureFigures.followers) do
                if follower.owner == activePlayers[currentPlayer] and table.contains(FOLLOWER_TYPES, follower.figureName) then
                    playerHasFollower = true
                end
            end

            if joinedActiveFigures[featureNum] == nil then
                joinedActiveFigures[featureNum] = {}
                joinedActiveFigures[featureNum].followers = {}
                joinedActiveFigures[featureNum].specialFigures = {}
                unoccupiedFeature = true
            end
            traversedOpenings = {}
            if #featureFigures.followers == 0 and
                not (nameOfFeature == 'Road' and controlPanelSettings['BaseDisableRoads']) and
                not (nameOfFeature == 'City' and controlPanelSettings['BaseDisableCities']) and
                not (nameOfFeature == 'Cloister' and controlPanelSettings['BaseDisableCloisters']) and
                not (nameOfFeature == 'Field' and controlPanelSettings['BaseDisableFarms']) then

                local unoccupiedFeature = false

                local usedFeature = false
                local fieldHasBarn = false
                if (nameOfFeature == 'Field' and #featureFigures.specialFigures > 0) then
                    for _, figure in ipairs(featureFigures.specialFigures) do
                        if figure.figureName == 'Barn' then
                            fieldHasBarn = true
                        end
                    end
                end
                if not fieldHasBarn and (baselineFollowerCounts[activePlayers[currentPlayer]] > 0 or baselineFigures[activePlayers[currentPlayer]]['Big Follower']) then
                    if baselineFollowerCounts[activePlayers[currentPlayer]] > 0 then
                        table.insert(joinedActiveFigures[featureNum].followers, {figureName="Follower", owner=activePlayers[currentPlayer], tile_guid=newTile.getGUID()})
                        AICalculateActiveScores(xIndex, zIndex, tileRotation, featureNum)
                        local followerScore = AICalculateCurrentPlayerScoreBenefit()
                        if numOpenings > 0 or nameOfFeature == 'Field' then
                            followerScore = followerScore + spareFollowerAdjustment
                        end
                        debugMessage(1, "followerScore at feature " .. featureNum .. ":" .. followerScore)
                        if followerScore == highestScore then
                            --debugMessage(1, "found identical meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                            numIdenticalScore = numIdenticalScore + 1
                        end
                        if followerScore > highestScore or (math.random(numIdenticalScore) == 1 and followerScore == highestScore) then -- this is to lessen the bias towards one side of the play area
                            --debugMessage(1, "found new best meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. tilePosition)
                            --debugMessage(1, "moveScore:".. moveScore .. " spareFollowerAdjustment:" .. spareFollowerAdjustment .. " openFeaturePenalty:" .. numOpenings * OPEN_FEATURE_PENALTY .. " featureScore:" .. featureScore)
                            if followerScore > highestScore then
                                numIdenticalScore = 1
                            end
                            highestScore = followerScore
                            highestScoreX = xIndex
                            highestScoreZ = zIndex
                            highestScoreRot = tileRotation
                            highestScorePos = featureMapPosition
                            highestScoreFigure = 'Follower'
                            usedFeature = true
                        end
                        table.remove(joinedActiveFigures[featureNum].followers)
                    end
                    if baselineFigures[activePlayers[currentPlayer]]['Big Follower'] then
                        table.insert(joinedActiveFigures[featureNum].followers, {figureName="Big Follower", owner=activePlayers[currentPlayer], tile_guid=newTile.getGUID()})
                        AICalculateActiveScores(xIndex, zIndex, tileRotation, featureNum)
                        local followerScore = AICalculateCurrentPlayerScoreBenefit()
                        if numOpenings > 0 then
                            followerScore = followerScore + spareFollowerAdjustment
                        end
                        debugMessage(1, "bigFollowerScore at feature " .. featureNum .. ":" .. followerScore)
                        if followerScore == highestScore then
                            --debugMessage(1, "found identical meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. featureMapPosition)
                            numIdenticalScore = numIdenticalScore + 1
                        end
                        if followerScore > highestScore then
                            --debugMessage(1, "found new best meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. featureMapPosition)
                            --debugMessage(1, "moveScore:".. moveScore .. " spareFollowerAdjustment:" .. spareFollowerAdjustment .. " openFeaturePenalty:" .. numOpenings * OPEN_FEATURE_PENALTY .. " featureScore:" .. featureScore)
                            if followerScore > highestScore then
                                numIdenticalScore = 1
                            end
                            highestScore = followerScore
                            highestScoreX = xIndex
                            highestScoreZ = zIndex
                            highestScoreRot = tileRotation
                            highestScorePos = featureMapPosition
                            highestScoreFigure = 'Big Follower'
                            usedFeature = true
                        end
                        table.remove(joinedActiveFigures[featureNum].followers)
                    end
                end
                if unoccupiedFeature then --get rid of temporary figures
                    joinedActiveFigures[featureNum] = nil
                end
                if not usedFeature and nameOfFeature ~= 'Field' and nameOfFeature ~= 'Cloister' then
                    local featureScore = 0
                    for featureKey, joinPercentage in pairs(featureJoinPercentages) do
                        local features = string.split(featureKey, "+")

                        if table.contains(features, featureNumKey) then
                            local featureLocation = nil
                            local joinedFeatureFigures = {}
                            joinedFeatureFigures.followers = {}
                            joinedFeatureFigures.specialFigures = {}
                            joinedFeatureFigures.sheepTokens = {}
                            local joinedSpecialFeatures = {}
                            local joinedNumTiles = 0
                            local joinedOpenings = 1
                            local joinedOpeningCoords = {}
                            local joinedFeatureNums = {}

                            for _, joinedFeatureNum in ipairs(features) do
                                table.insert(joinedFeatureNums, joinedFeatureNum)

                                local joinedFeature = tempFeatureList[joinedFeatureNum]
                                if joinedFeature == nil then joinedFeature = featureList[joinedFeatureNum] end
                                if joinedFeature ~= nil then
                                    for _,v in ipairs(joinedFeature.specialFeatures) do table.insert(joinedSpecialFeatures, v) end
                                    for k,v in pairs(joinedFeature.openingCoords) do joinedOpeningCoords[k] = v end

                                    joinedNumTiles = joinedNumTiles + joinedFeature.numTiles --worth noting that this will inflate the value of features which re-use the same tile. No easy way to fix this, but I don't think it will make a huge difference.
                                    joinedOpenings = joinedOpenings + joinedFeature.numOpenings - 1
                                end
                            end
                            local featureJoinPercentage = joinPercentage.percentage
                            if featureJoinPercentage > MAX_JOIN_PERCENTAGE then featureJoinPercentage = MAX_JOIN_PERCENTAGE end
                            local connectedFeature = AICalculateFeatureScore(featureBlockPercentages[featureKey], joinedFeatureNums, nameOfFeature, joinedSpecialFeatures, joinedOpenings, joinedOpeningCoords, joinedNumTiles, featureLocation, featureFigures, true)

                            featureScore = featureScore + featureJoinPercentage * connectedFeature
                        end
                    end
                    if featureScore > highestUnusedFeature then
                        debugMessage(1, "new highest unused featureNum: " .. featureNum .. " :" .. featureScore)
                        highestUnusedFeature = featureScore
                    end
                end
            elseif playerHasFollower and nameOfFeature == 'Field' and baselineFigures[activePlayers[currentPlayer]]['Pig'] then
                table.insert(joinedActiveFigures[featureNum].specialFigures, {figureName="Pig", owner=activePlayers[currentPlayer], tile_guid=newTile.getGUID()})
                AICalculateActiveScores(xIndex, zIndex, tileRotation, featureNum)
                local pigScore = AICalculateCurrentPlayerScoreBenefit()
                debugMessage(1, "pigScore at feature " .. featureNum .. ":" .. pigScore)
                if pigScore > highestScore then
                    --debugMessage(1, "found new best meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. featureMapPosition)
                    --debugMessage(1, "moveScore:".. moveScore .. " spareFollowerAdjustment:" .. spareFollowerAdjustment .. " openFeaturePenalty:" .. numOpenings * OPEN_FEATURE_PENALTY .. " featureScore:" .. featureScore)

                    numIdenticalScore = 1
                    highestScore = pigScore
                    highestScoreX = xIndex
                    highestScoreZ = zIndex
                    highestScoreRot = tileRotation
                    highestScorePos = featureMapPosition
                    highestScoreFigure = 'Pig'
                end
                table.remove(joinedActiveFigures[featureNum].specialFigures)
            elseif playerHasFollower and numOpenings > 0 and (nameOfFeature == 'City' or nameOfFeature == 'Road') and baselineFigures[activePlayers[currentPlayer]]['Builder'] then
                --table.insert(joinedActiveFigures[featureNum].specialFigures, {figureName="Builder", owner=activePlayers[currentPlayer], tile_guid=newTile.getGUID()})
                local builderScore = moveScore + BUILDER_PLACEMENT_BONUS_VALUE

                --we don't need to call AICalculateActiveScores again because the only difference in score should be the block penalty, so calculate it here
                local blockPenalty = STUCK_BUILDER_PENALTY * numRemainingMoves
                blockPenalty = blockPenalty * featureBlockPercentages["" .. featureNum] ^ BLOCK_PERCENTAGE_POWER_MODIFIER
                builderScore = builderScore - blockPenalty

                --debugMessage(1, "considering builder with blockPenalty:" .. blockPenalty .. " blockPercentage:" .. featureBlockPercentages["" .. featureNum])
                if builderScore == highestScore then
                    --debugMessage(1, "found identical builder score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. featureMapPosition)
                    numIdenticalScore = numIdenticalScore + 1
                end
                debugMessage(1, "builderScore at feature " .. featureNum .. ":" .. builderScore)
                if builderScore > highestScore or (math.random(numIdenticalScore) == 1 and builderScore == highestScore) then -- this is to lessen the bias towards one side of the play area
                    --debugMessage(1, "found new best builder score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. featureMapPosition)
                    if builderScore > highestScore then
                        numIdenticalScore = 1
                    end
                    highestScore = builderScore
                    highestScoreX = xIndex
                    highestScoreZ = zIndex
                    highestScoreRot = tileRotation
                    highestScorePos = featureMapPosition
                    highestScoreFigure = 'Builder'
                end
                --table.remove(joinedActiveFigures[featureNum].specialFigures)
            end
            if nameOfFeature == 'Field' and numOpenings > 0 and baselineFigures[activePlayers[currentPlayer]]['Shepherd'] then
                local hasShepherd = false
                for _, specialFigure in ipairs(featureFigures.specialFigures) do
                    if specialFigure.figureName == "Shepherd" then
                        hasShepherd = true
                    end
                end
                if not hasShepherd then
                    table.insert(joinedActiveFigures[featureNum].specialFigures, {figureName="Shepherd", owner=activePlayers[currentPlayer], tile_guid=newTile.getGUID()})
                    AICalculateActiveScores(xIndex, zIndex, tileRotation, featureNum)
                    --the shepherd extend value will be added in AICalculateActiveScores, which it shouldn't be
                    activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] - SHEPHERD_EXTEND_VALUE
                    local shepherdScore = AICalculateCurrentPlayerScoreBenefit() + newShepherdValue
                    debugMessage(1, "shepherdScore at feature " .. featureNum .. ":" .. shepherdScore)
                    if shepherdScore > highestScore then
                        --debugMessage(1, "found new best meeple score: " .. score .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation .. " pos:" .. featureMapPosition)
                        --debugMessage(1, "moveScore:".. moveScore .. " spareFollowerAdjustment:" .. spareFollowerAdjustment .. " openFeaturePenalty:" .. numOpenings * OPEN_FEATURE_PENALTY .. " featureScore:" .. featureScore)

                        numIdenticalScore = 1
                        highestScore = shepherdScore
                        highestScoreX = xIndex
                        highestScoreZ = zIndex
                        highestScoreRot = tileRotation
                        highestScorePos = featureMapPosition
                        highestScoreFigure = 'Shepherd'
                    end
                    table.remove(joinedActiveFigures[featureNum].specialFigures)
                end
            end
            featureVisited[featureNum] = true
            featureJoinPercentages = tempFeatureJoinPercentages
            featureBlockPercentages = tempFeatureBlockPercentages
        end
    end
    moveScore = moveScore - highestUnusedFeature * 0.3 -- meant to slightly disourage from building a feature for someone else to take
    debugMessage(1, "adjusting score for highest unused feature: " .. highestUnusedFeature)
    if moveScore == highestScore then
        --debugMessage(1, "found identical tile score: " .. moveScore .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        numIdenticalScore = numIdenticalScore + 1
    end
    if moveScore > highestScore or (math.random(numIdenticalScore) == 1 and moveScore == highestScore) then -- this is to lessen the bias towards one side of the play area
        --debugMessage(1, "found new best tile score: " .. moveScore .. " at x:" .. xIndex .. " z:" .. zIndex .. " rot:" .. tileRotation)
        if moveScore > highestScore then
            numIdenticalScore = 1
        end
        highestScore = moveScore
        highestScoreX = xIndex
        highestScoreZ = zIndex
        highestScoreRot = tileRotation
        highestScorePos = nil
        highestScoreFigure = nil
    end
    tileGrid[xIndex][zIndex] = nil
end

--calculate the value to the current player, based not only on the score that they gained but also the change to their opponent's score
function AICalculateCurrentPlayerScoreBenefit()
    local scoreChange = {}
    local moveScore = 0
    for _, player in ipairs(activePlayers) do
        scoreChange[player] = activeScores[player] - baselineScores[player]
    end
    for _, player in ipairs(activePlayers) do
        if player == activePlayers[currentPlayer] then
            moveScore = moveScore + scoreChange[player]
        elseif #activePlayers <= 2 then
            -- in 1-on-1 games, lowering our opponent's score is exactly equal to gaining points in all cases
            moveScore = moveScore - scoreChange[player]
        elseif activeScores[activePlayers[currentPlayer]] - activeScores[player] < SCORE_THREAT_THRESHOLD then
            -- if this opponent is within SCORE_THREAT_THRESHOLD points behind (after this move), then their gain in points hurts our position, so subtract a portion of those points
            moveScore = moveScore - (scoreChange[player] * (SCORE_THREAT_THRESHOLD - activeScores[activePlayers[currentPlayer]] + activeScores[player]) / SCORE_THREAT_THRESHOLD) / (#activePlayers - 1)
        end
    end
    return moveScore
end

--calculate an estimated score for each player based on their actual current score, plus values predicted from features they control
--if xIndex and zIndex are included, it will also include bonuses for having placed the tile at this position
function AICalculateActiveScores(newXIndex, newZIndex, tileRotation, featureNum)
    --debugMessage(2, "AI checking current active scores..")
    if os.clock() - lastFrameTime > FRAME_TIME then
        lastFrameTime = lastFrameTime + FRAME_TIME
        coroutine.yield(0)
    end

    activeScores = {}
    currentPlayerFollowerCountChange = 0
    for _, player in ipairs(activePlayers) do
        local scoreCounter = getObjectFromGUID(score_counter_guids[player])
        if scoreCounter ~= nil then
            activeScores[player] = getObjectFromGUID(score_counter_guids[player]).Counter.getValue()
        else
            activeScores[player] = 0
        end
    end

    local awardedTokens = {}
    if newXIndex ~= nil and (controlPanelSettings['TnBTradeGoods'] or controlPanelSettings['TnBBuilder'] or controlPanelSettings['HnSShepherd']) then
        --TODO: Verify if the following code will work for Abbey as well.
        for featureNum, feature in pairs(tempFeatureList) do
            if feature.numOpenings == 0 and feature.nameOfFeature == 'City' then
                for _, specialFeature in ipairs(feature.specialFeatures) do
                    if table.contains(TRADE_GOOD_TYPES, specialFeature) then
                        table.insert(awardedTokens, specialFeature)
                    end
                end
            end
            if joinedActiveFigures[featureNum] ~= nil then
                if feature.nameOfFeature == 'City' or feature.nameOfFeature == 'Road' then
                    for _, specialFigure in ipairs(joinedActiveFigures[featureNum].specialFigures) do
                        if specialFigure.owner == activePlayers[currentPlayer] then --do not give give extra builder tile (CAR ref 149)
                            if specialFigure.figureName == 'Builder' and not hasAlreadyTakenBuilderTile then
                                activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + BUILDER_EXTRA_TURN_VALUE
                            end
                        end
                    end
                elseif feature.nameOfFeature == 'Field' then
                    for _, specialFigure in ipairs(joinedActiveFigures[featureNum].specialFigures) do
                        if specialFigure.owner == activePlayers[currentPlayer] then --do not give give sheep (CAR ref 149)
                            if specialFigure.figureName == 'Shepherd' then
                                activeScores[activePlayers[currentPlayer]] = activeScores[activePlayers[currentPlayer]] + SHEPHERD_EXTEND_VALUE
                            end
                        end
                    end
                end
            end
        end
    end

    if controlPanelSettings['TnBTradeGoods'] then
        for _, tokenType in ipairs(TRADE_GOOD_TYPES) do
            local highestNumTokens = 0
            local secondHighestTokens = 0
            local tokenCount = table.shallow_copy(tradeTokenCounts[tokenType])
            for _, token in ipairs(awardedTokens) do
                if token == tokenType then
                    tokenCount[activePlayers[currentPlayer]] = tokenCount[activePlayers[currentPlayer]] + 1
                end
            end
            local numRemainingTokens = TRADE_TOKEN_COUNTS[tokenType] - blockedTokens[tokenType]
            --find the highest count for this token
            for _, player in ipairs(activePlayers) do
                if tokenCount[player] ~= nil and tokenCount[player] >= highestNumTokens then
                    secondHighestTokens = highestNumTokens
                    highestNumTokens = tokenCount[player]
                end
                numRemainingTokens = numRemainingTokens - tokenCount[player]
            end
            --tokens are only worth something if you are in first place or there are enough tokens left to catch up
            if highestNumTokens > 0 then
                for _, player in ipairs(activePlayers) do
                    if tokenCount[player] == highestNumTokens and highestNumTokens - secondHighestTokens <= numRemainingTokens then -- the player is guaranteed to win
                        activeScores[player] = activeScores[player] + 10
                    elseif highestNumTokens == tokenCount[player] then -- the player is ahead, but another player can still catch up
                        activeScores[player] = activeScores[player] + 10 / numRemainingTokens / #activePlayers --i don't know how to calculate this yet
                    elseif highestNumTokens - tokenCount[player] <= numRemainingTokens then -- the player is behind, but still has a chance to catch up
                        activeScores[player] = activeScores[player] + 10 / numRemainingTokens / #activePlayers --not sure how to calculate this yet
                    end
                end
            end
        end
    end
    for featureKey, joinPercentage in pairs(featureJoinPercentages) do
        local nameOfFeature = nil
        local featureLocation = nil
        local joinedFeatureFigures = {}
        joinedFeatureFigures.followers = {}
        joinedFeatureFigures.specialFigures = {}
        joinedFeatureFigures.sheepTokens = {}
        local joinedSpecialFeatures = {}
        local joinedNumTiles = 0
        local joinedOpenings = 1
        local joinedOpeningCoords = {}
        local joinedFeatureNums = {}

        local features = string.split(featureKey, "+")
        for _, joinedFeatureNum in ipairs(features) do
            table.insert(joinedFeatureNums, joinedFeatureNum)
            if joinedActiveFigures[joinedFeatureNum] ~= nil then
                for _,v in ipairs(joinedActiveFigures[joinedFeatureNum].followers) do table.insert(joinedFeatureFigures.followers, v) end
                for _,v in ipairs(joinedActiveFigures[joinedFeatureNum].specialFigures) do table.insert(joinedFeatureFigures.specialFigures, v) end
            end
            if joinedActiveNeutralFigures[joinedFeatureNum] ~= nil then
                for _,v in ipairs(joinedActiveNeutralFigures[joinedFeatureNum].sheepTokens) do table.insert(joinedFeatureFigures.sheepTokens, v) end
            end

            local joinedFeature = tempFeatureList[joinedFeatureNum]
            if joinedFeature == nil then joinedFeature = featureList[joinedFeatureNum] end
            if joinedFeature ~= nil then
                if nameOfFeature == nil then
                    nameOfFeature = joinedFeature.nameOfFeature
                    featureLocation = joinedFeature.featureLocation
                end
                for _,v in ipairs(joinedFeature.specialFeatures) do table.insert(joinedSpecialFeatures, v) end
                for k,v in pairs(joinedFeature.openingCoords) do joinedOpeningCoords[k] = v end

                joinedNumTiles = joinedNumTiles + joinedFeature.numTiles --worth noting that this will inflate the value of features which re-use the same tile. No easy way to fix this, but I don't think it will make a huge difference.
                joinedOpenings = joinedOpenings + joinedFeature.numOpenings - 1
            else
                print("ERROR: featureNum " .. joinedFeatureNum .. " does not exist! featureKey:" .. featureKey .. " Please report this to the dev.")
            end
        end
        local joinedFeatureScore = AICalculateFeatureScore(featureBlockPercentages[featureKey], joinedFeatureNums, nameOfFeature, joinedSpecialFeatures, joinedOpenings, joinedOpeningCoords, joinedNumTiles, featureLocation, joinedFeatureFigures, false)

        -- if ((newXIndex == 13 and newZIndex == 18 and tileRotation == 1 and featureNum == nil) or newXIndex == nil) then
        --     print("feature:" .. featureKey .. " type:" .. nameOfFeature .. " join%:" .. joinPercentage.percentage .. " block%:" .. featureBlockPercentages[featureKey])
        -- end
        local featureJoinPercentage = joinPercentage.percentage
        if featureJoinPercentage > MAX_JOIN_PERCENTAGE then featureJoinPercentage = MAX_JOIN_PERCENTAGE end

        for _, player in ipairs(activePlayers) do
            activeScores[player] = activeScores[player] + joinedFeatureScore[player] * featureJoinPercentage
            -- if joinedFeatureScore[player] ~= 0 and ((newXIndex == 13 and newZIndex == 18 and tileRotation == 1 and featureNum == nil) or newXIndex == nil) then
            --     print("feature:" .. featureKey .. " player: " .. player .. " score:" .. joinedFeatureScore[player] * joinPercentage.percentage)
            -- end
        end
    end
end

--Calculate the "rough" percentages that different features will connect to each other. Note that right now, these numbers don't mean too much and
--don't expect expect anything to add up to 100%
function AICalculateFeatureJoinPercentages()
    featureJoinPercentages = {}
    featureBlockPercentages = {}

    for featureNum, featureFigures in pairs(joinedActiveFigures) do
        -- if os.clock() - lastFrameTime > FRAME_TIME then
        --     lastFrameTime = lastFrameTime + FRAME_TIME
        --     coroutine.yield(0)
        -- end
        local traversedOpenings = {}
        local featureKey = "" .. featureNum
        local feature = tempFeatureList[featureNum]
        if feature == nil then feature = featureList[featureNum] end
        local openingCoords = table.shallow_copy(feature.openingCoords)
        featureJoinPercentages[featureKey] = {}
        featureJoinPercentages[featureKey].percentage = 1
        featureJoinPercentages[featureKey].openings = {}

        AICalculateFeatureJoinPercentage(traversedOpenings, {featureNum}, featureKey, openingCoords, featureJoinPercentages, 1, featureBlockPercentages)
    end
end

function AICalculateFeatureJoinPercentage(traversedJoinOpenings, joinedFeatureNums, joinedFeaturesKey, joinedOpeningCoords, featureJoinPercentages, prevJoinPercentage, featureBlockPercentages)
    --debugMessage(1, "start: " .. joinedFeaturesKey)
    local traversedBlockOpenings = {}
    if featureBlockPercentages[joinedFeaturesKey] == nil then
        featureBlockPercentages[joinedFeaturesKey] = 0
    end
    for openingCoord, _ in pairs(joinedOpeningCoords) do
        --debugMessage(1, "openingCoord: " .. openingCoord)
        if traversedBlockOpenings[openingCoord] == nil then
            traversedBlockOpenings[openingCoord] = true
            local connectionOdds
            if tempTileConnectionOdds ~= nil and tempTileConnectionOdds[openingCoord] ~= nil then
                connectionOdds = tempTileConnectionOdds[openingCoord]
            else
                connectionOdds = tileConnectionOdds[openingCoord]
            end
            if connectionOdds ~= nil then --if it is still nil, this is probably a "proximity feature" that doesn't have neighbors yet
                if traversedJoinOpenings[openingCoord] == nil then
                    traversedJoinOpenings[openingCoord] = true
                    for _, featureNum in ipairs(joinedFeatureNums) do
                        --if joinedActiveFigures[featureNum] ~= nil or tempFeatureList[featureNum] ~= nil then
                        --debugMessage(1, "featureNum: " .. featureNum)
                        for connectionStat, odds in pairs(connectionOdds) do
                            local features = string.split(connectionStat, "+")
                            local featureNumPresent = false
                            for _, value in ipairs(features) do
                                if tempJoinedFeature[value] ~= nil then --if the feature number had changed due to joining with another feature, use that number
                                    value = tempJoinedFeature[value]
                                end
                                if value == featureNum then
                                    featureNumPresent = true
                                    break
                                end
                            end
                            if featureNumPresent then
                                --if connectionStat ~= "close+" .. featureNum and connectionStat ~= "extend+" .. featureNum then
                                    local nestedJoinedFeatureNums = table.shallow_copy(joinedFeatureNums)
                                    local nestedJoinedOpeningCoords = table.shallow_copy(joinedOpeningCoords)
                                    local foundNewFeatureNum = false
                                    for _, joinedFeatureNum in ipairs(features) do
                                        --FIXME: Currently only check a connected feature if it has an active figure. This is to save computation time. However it makes the behavior not as smart. Fix during optimization.
                                        --Also, if there is a case where a tile is added between two features that aren't normally joined, it can cause the AI to join them and think it is a powerful move, even if it does nothing.
                                        if (joinedActiveFigures[joinedFeatureNum] ~= nil or tempFeatureList[joinedFeatureNum] ~= nil) and table.bininsertnodup(nestedJoinedFeatureNums, joinedFeatureNum) ~= nil then
                                        --if table.bininsertnodup(nestedJoinedFeatureNums, joinedFeatureNum) ~= nil then
                                            foundNewFeatureNum = true
                                            local joinedFeature = tempFeatureList[joinedFeatureNum]
                                            if joinedFeature == nil then joinedFeature = featureList[joinedFeatureNum] end
                                            for k,v in pairs(joinedFeature.openingCoords) do nestedJoinedOpeningCoords[k] = v end
                                        end
                                    end
                                    if foundNewFeatureNum then
                                        local key = table.concat(nestedJoinedFeatureNums,"+")
                                        if key ~= joinedFeaturesKey then
                                            --the following makes the assumption that exactly 1 player would want to do this move if given the chance
                                            local joinPercentage = odds / connectionOdds["totalValid"] * (1 - (1 - (1 / #activePlayers)) ^ odds)
                                            -- if joinPercentage > MAX_JOIN_PERCENTAGE then joinPercentage = MAX_JOIN_PERCENTAGE end
                                            if featureJoinPercentages[key] == nil then
                                                local nestedTraversedJoinOpenings = table.shallow_copy(traversedJoinOpenings)
                                                --debugMessage(1, "connected to " .. key .. " with joinPercentage:" .. joinPercentage .. " prevJoinPercentage:" .. prevJoinPercentage)
                                                featureJoinPercentages[key] = {}
                                                featureJoinPercentages[key].percentage = joinPercentage * prevJoinPercentage
                                                featureJoinPercentages[key].openings = {}
                                                featureJoinPercentages[key].openings[openingCoord] = true
                                                featureJoinPercentages[joinedFeaturesKey].openings[openingCoord] = true
                                                featureJoinPercentages[joinedFeaturesKey].percentage = featureJoinPercentages[joinedFeaturesKey].percentage * (1 - joinPercentage)
                                                AICalculateFeatureJoinPercentage(nestedTraversedJoinOpenings, nestedJoinedFeatureNums, key, nestedJoinedOpeningCoords, featureJoinPercentages, joinPercentage, featureBlockPercentages)
                                            elseif featureJoinPercentages[key].openings[openingCoord] == nil then
                                                --debugMessage(1, "reconnected to " .. key .. " with joinPercentage:" .. joinPercentage .. " prevJoinPercentage:" .. prevJoinPercentage)
                                                featureJoinPercentages[key].openings[openingCoord] = true
                                                featureJoinPercentages[key].percentage = 1 - ((1 - featureJoinPercentages[key].percentage) * (1 - (joinPercentage * prevJoinPercentage)))
                                                featureJoinPercentages[joinedFeaturesKey].openings[openingCoord] = true
                                                featureJoinPercentages[joinedFeaturesKey].percentage = featureJoinPercentages[joinedFeaturesKey].percentage * (1 - joinPercentage)
                                            end
                                            if featureJoinPercentages[joinedFeaturesKey].openings[openingCoord] == nil then
                                                featureJoinPercentages[joinedFeaturesKey].openings[openingCoord] = true
                                                featureJoinPercentages[joinedFeaturesKey].percentage = featureJoinPercentages[joinedFeaturesKey].percentage * (1 - joinPercentage)
                                            end
                                        end
                                    --end
                                end
                            end
                        --end
                        end
                    end
                end
                local numCards
                if NUMBER_OF_DRAWN_TILES_FOR_BLOCK_PERCENTAGE < numRemainingMoves then
                    numCards = NUMBER_OF_DRAWN_TILES_FOR_BLOCK_PERCENTAGE
                else
                    numCards = numRemainingMoves
                end
                if connectionOdds["blocked"] > tilesRemaining + buriedTileCount then
                    if not alreadyPrintedErrorMessage then
                        --print("ERROR:" .. openingCoord .. " block%:" .. featureBlockPercentages[joinedFeaturesKey] .. " blockOdds:" .. connectionOdds["blocked"] .. " tilesRemaining:" .. tilesRemaining)
                        debugMessage(1, "ERROR:" .. openingCoord .. " block%:" .. featureBlockPercentages[joinedFeaturesKey] .. " blockOdds:" .. connectionOdds["blocked"] .. " tilesRemaining:" .. tilesRemaining + buriedTileCount)
                        alreadyPrintedErrorMessage = true
                    end
                    featureBlockPercentages[joinedFeaturesKey] = 1
                elseif tilesRemaining == 0 then
                    featureBlockPercentages[joinedFeaturesKey] = 1
                else
                    featureBlockPercentages[joinedFeaturesKey] = 1 - ((1 - featureBlockPercentages[joinedFeaturesKey]) * (1 - (connectionOdds["blocked"] / (tilesRemaining + buriedTileCount)) ^ numCards))
                end
            end
        end
    end
    --debugMessage(1, "finish " .. joinedFeaturesKey)
end

function AICalculateFeatureScore(blockPercentage, featureNums, nameOfFeature, specialFeatures, numOpenings, openingCoords, numTiles, featureLocation, featureFigures, getFeatureValue)
    --debugMessage(3, "AICalculateFeatureScore")
    local featureScore = {}
    for _, player in ipairs(activePlayers) do
        featureScore[player] = 0
    end
    if nameOfFeature == 'River' or nameOfFeature == 'Carcassonne' then --ensure illegal moves are never chosen
        featureScore[activePlayers[currentPlayer]] = -1000
    end

    local featureComplete
    if numOpenings == 0 then
        featureComplete = true
    else
        featureComplete = false
    end


    local followerCounts = {}
    local hasHill = {}
    local hasMayor = {}
    local topWeight = -1

    --find the relative weights for the followers on this feature
    for _, follower in ipairs(featureFigures.followers) do
        if numOpenings == 0 and nameOfFeature ~= 'Field' then
            if follower.owner == activePlayers[currentPlayer] then
                currentPlayerFollowerCountChange = currentPlayerFollowerCountChange + 1
            end
        end
        if numRemainingMoves + 1 > baselineFollowerCounts[follower.owner] and (numOpenings > 0 or nameOfFeature == 'Field') then
            local movesWithoutFollowers = numRemainingMoves + 1 - baselineFollowerCounts[follower.owner]
            local blockPenalty
            if follower.figureName == 'Big Follower' then
                blockPenalty = STUCK_BIG_FOLLOWER_PENALTY * movesWithoutFollowers
            else
                blockPenalty = STUCK_FOLLOWER_PENALTY * movesWithoutFollowers
            end
            if nameOfFeature ~= 'Field' then
                blockPenalty = blockPenalty * blockPercentage ^ BLOCK_PERCENTAGE_POWER_MODIFIER
            end
            featureScore[follower.owner] = featureScore[follower.owner] - blockPenalty
            --debugMessage(1, "score:" .. score .. " blockPenalty:" .. blockPenalty .. " blockPercentage:" .. blockPercentage)
        end
        local weight = 0
        if follower.figureName == 'Follower' or follower.figureName == 'Wagon' or follower.figureName == 'Abbot' then weight = 1
        elseif follower.figureName == 'Big Follower' then weight = 2
        elseif follower.figureName == 'Mayor' then
            for _, specialFeature in ipairs(traversedSpecialFeatures) do
                if specialFeature == 'Pennant' then weight = weight + 1 end
            end
            hasMayor[follower.owner] = true
        end
        if weight > 0 then
            local specialFeatures = getObjectFromGUID(follower.tile_guid).getTable('specialFeatures')
            if controlPanelSettings['HnSHills'] and specialFeatures ~= nil then
                for _, specialFeature in ipairs(specialFeatures) do
                    if specialFeature[1] == "Hill" then
                        --although it would have been easier to just add 0.001 to the weight here, it would have technically violated the rules, since multiple hills are not supposed to give extra weight.
                        hasHill[follower.owner] = true
                    end
                end
            end
        end
        if followerCounts[follower.owner] == nil then
            followerCounts[follower.owner] = weight
        else
            followerCounts[follower.owner] = followerCounts[follower.owner] + weight
        end
    end

    local hasPig = {}
    --local hasBarn = false
    --local hasNewBarn = false

    local sheepScore = 0
    local currentPlayerHasShepherd = false

    for _, token in ipairs(featureFigures.sheepTokens) do
        if token.tokenName == 'Sheep' then
            sheepScore = sheepScore + token.count
        -- elseif token.getVar('tokenName') == 'Wolf' then
        --     hasWolf = true
        end
    end
    --loop through once to find out if the current player is sharing the field
    -- for _, specialFigure in ipairs(featureFigures.specialFigures) do
    --     if specialFigure.figureName == 'Shepherd' and specialFigure.owner == activePlayers[currentPlayer] then
    --         currentPlayerHasShepherd = true
    --     end
    -- end

    --calculate special figure scores and add extra penalty for special figures that are stuck
    for _, specialFigure in ipairs(featureFigures.specialFigures) do
        if specialFigure.figureName == 'Pig' then
            --this stuck penalty is intended to force the AI to wait until later in the game to use the pig
            hasPig[specialFigure.owner] = true
            local blockPenalty = STUCK_PIG_PENALTY * numRemainingMoves
            featureScore[specialFigure.owner] = featureScore[specialFigure.owner] - blockPenalty
        elseif specialFigure.figureName == 'Shepherd' then
            if currentPlayerHasShepherd or numOpenings > 0 then
                featureScore[specialFigure.owner] = featureScore[specialFigure.owner] + sheepScore
            end
            --extra penalty should not apply to a shepherd if the current player has a shepherd in the field, since they will take the shepherds back if it is too high
            -- if not currentPlayerHasShepherd then
            --     local blockPenalty = STUCK_SHEPHERD_PENALTY * numRemainingMoves
            --     blockPenalty = blockPenalty * blockPercentage ^ BLOCK_PERCENTAGE_POWER_MODIFIER
            --     featureScore[specialFigure.owner] = featureScore[specialFigure.owner] - blockPenalty
            -- end
        elseif specialFigure.figureName == 'Builder' and numOpenings > 0 then
            local blockPenalty = STUCK_BUILDER_PENALTY * numRemainingMoves
            blockPenalty = blockPenalty * blockPercentage ^ BLOCK_PERCENTAGE_POWER_MODIFIER
            featureScore[specialFigure.owner] = featureScore[specialFigure.owner] - blockPenalty
            --debugMessage(1, specialFigure.owner .. " " .. specialFigure.figureName .. " blockPenalty:" .. blockPenalty .. " blockPercentage:" .. blockPercentage)
        end
        -- if figure.figureName == 'Barn' then
        --     hasBarn = true
        --     if newBarn ~= nil and figure.getGUID() == newBarn then
        --         hasNewBarn = true
        --         newBarn = nil
        --     end
        --     --recalculate "follower count" with only barns. Technically they aren't followers but it was easier in code.
        --     if #traversedFollowers == 0 then
        --         if followerCounts[figure.owner] == nil then
        --             followerCounts[figure.owner] = 1
        --         else
        --             followerCounts[figure.owner] = followerCounts[figure.owner] + 1
        --         end
        --         if followerCounts[figure.owner] > topWeight then topWeight = followerCounts[figure.owner] end
        --     end
        -- end
    end
    --add hill weight if there is a hill, find top weight for the feature
    for player, value in pairs(followerCounts) do
        if hasHill[player] then
            --if the follower is on a hill, add a small value to it to break any ties
            followerCounts[player] = followerCounts[player] + 0.001
        end
        if followerCounts[player] > topWeight then topWeight = followerCounts[player] end
    end
    -- local eligibleFollowers = fairyEligibleFollowers()
    -- for _, eligibleFollower in ipairs(eligibleFollowers) do
    --     if eligibleFollower == follower then
    --         allGameMessage({"MESSAGE_SCORE_FAIRY_FINISH", {'{c1}', eligibleFollower.getDescription()}, {'{f1}', eligibleFollower.getName()}}, player_color_tints[eligibleFollower.getVar('owner')])
    --         scorePoints(eligibleFollower.owner, 'Fairy', 3)
    --     end
    -- end
    -- if follower.figureName == "Wagon" then
    --     wagonLocations[follower.owner] = {}
    --     wagonLocations[follower.owner].x = follower.getPosition().x
    --     wagonLocations[follower.owner].z = follower.getPosition().z
    --     hasAvailableWagonFeature[follower.owner] = hasIncompleteSecondaryFeature
    -- end
    -- local winner = false

    local score = 0
    local containsPigHerd = false
    local scoreMultiplier = nil -- a separate multiplier per player is sometimes needed (ie. pig on a farm)
    if not controlPanelSettings['BaseDisableCities'] and nameOfFeature == 'City' then
        local tokenBonus = 0
        score = numTiles
        local containsCathedral = false
        for _, feature in ipairs(specialFeatures) do
            if feature == 'Pennant' then
                score = score + 1
            elseif table.contains(TRADE_GOOD_TYPES, feature) and numOpenings > 0 then
                --HACK: having the tokens in your city don't provide any value until they are finished, but in reality it can be
                --beneficial to have a token in your city, since you will likely work towards finished a city that you possess
                --also, another player may add points to your city by finishing it in order to get the token. For this reason,
                --we give a bonus to the trade token so that the AI will prefer to include them in their own cities
                tokenBonus = tokenBonus + UNFINISHED_TRADE_TOKEN_VALUE
            end
            if controlPanelSettings['InCCathedrals'] and feature == 'Cathedral' then
                containsCathedral = true
            end
        end
        if containsCathedral then
            if featureComplete then
                score = score * 3
            else
                if numRemainingMoves > numOpenings then
                    score = (score * 3 + tokenBonus) * (1 - blockPercentage)
                else
                    score = 0
                end
            end
        else
            if featureComplete then
                score = score * 2
            else
                if numRemainingMoves > numOpenings then
                    score = score + ((score + tokenBonus) * (1 - blockPercentage))
                else
                    -- score stays the same
                end
            end
        end

        if lastPlacedTileX ~= nil then --TODO: This broke something when lastPlacedTileX was null. Is lastPlacedTileX even used when checking possible moves? Wrapping in this if statement for now as a temporary fix
            local tileFeatures = tileGrid[lastPlacedTileX][lastPlacedTileZ].tileFeatures
            local isAbbey = false
            if tileFeatures ~= nil then
                for _, tileFeature in ipairs(tileFeatures) do
                    if tileFeature == 'Abbey' then
                        isAbbey = true
                    end
                end
            end
            --do not nerf cities that were completed by an abbey, or incomplete cities
            if not isAbbey and featureComplete and controlPanelSettings['BaseNerfSmallCity'] and score == 4 then
                score = 2
            end
        end
    elseif nameOfFeature == 'Field' and not controlPanelSettings['BaseDisableFarms'] then
        local numCities = 0

        local linkedCities = {}
        for _, featureNum in ipairs(featureNums) do
            local linkedFeatureCities = tempLinkedFeatures['City-Field'][featureNum]
            if linkedFeatureCities == nil then linkedFeatureCities = linkedFeatures['City-Field'][featureNum] end
            if linkedFeatureCities ~= nil then
                for k,v in pairs(linkedFeatureCities) do linkedCities[k] = v end
            end
        end
        for connectedFeatureNum, _ in pairs(linkedCities) do
            local numOpenings
            if tempFeatureList[connectedFeatureNum] ~= nil then
                numOpenings = tempFeatureList[connectedFeatureNum].numOpenings
            else
                numOpenings = featureList[connectedFeatureNum].numOpenings
            end
            if numOpenings == 0 then
                numCities = numCities + 1
            end
        end
        if not controlPanelSettings['RIIDisablePigherd'] then
            for _, feature in ipairs(specialFeatures) do
                -- if feature == 'Completed City' then
                --     numCities = numCities + 1
                -- end
                if feature == 'Pig-herd' then
                    containsPigHerd = true
                end
            end
        end
        featureComplete = false --so that this feature won't be scored before the end of the game
        local farmMultiplier = 3
        -- if hasBarn then
        --     if #traversedFollowers > 0 then
        --         if not hasNewBarn then
        --             farmMultiplier = 1
        --         end
        --     else
        --         farmMultiplier = 4
        --     end
        -- end
        if containsPigHerd and #featureFigures.followers > 0 then -- CAR pg 67 ref 194
            farmMultiplier = farmMultiplier + 1
        end
        scoreMultiplier = {}
        for player, value in pairs(followerCounts) do
            if (topWeight > 0 and value >= topWeight) then
                if hasPig[player] ~= nil then
                    scoreMultiplier[player] = farmMultiplier + 1
                else
                    scoreMultiplier[player] = farmMultiplier
                end
            end
        end
        score = numCities
    elseif not controlPanelSettings['BaseDisableRoads'] and nameOfFeature == 'Road' then
        score = numTiles
        local containsInn = false
        if controlPanelSettings['InCInns'] then
            for _, feature in ipairs(specialFeatures) do
                if feature == 'Inn' then
                    containsInn = true
                end
            end
        end

        if containsInn then
            if featureComplete then
                score = score * 3
            else
                if numRemainingMoves > numOpenings then
                    score = score * 2 * (1 - blockPercentage)
                else
                    score = 0
                end
            end
        end
    elseif not controlPanelSettings['BaseDisableCloisters'] and table.contains(CLOISTER_FEATURES, nameOfFeature) then
        score = 1
        for x=-1, 1 do
            for z=-1, 1 do
                if not (x == 0 and z == 0) then
                    local nestedX = featureLocation.x + x
                    local nestedZ = featureLocation.z + z
                    if tileGridOccupied(nestedX, featureLocation.z + z) then
                        score = score + 1
                        if controlPanelSettings['HnSVineyards'] then
                            local specialFeatures = getObjectFromGUID(tileGrid[nestedX][featureLocation.z + z].tile_guid).getTable('specialFeatures')
                            if specialFeatures ~= nil then
                                for _, feature in ipairs(specialFeatures) do
                                    if feature == 'Vineyard' then
                                        if featureComplete then
                                            score = score + 3
                                        elseif numRemainingMoves > numOpenings then
                                            score = score + 3 * (1 - blockPercentage)
                                        end
                                    end
                                end
                            end
                        end
                    else
                        local openingCoord = nestedX .. "-" .. nestedZ
                        local connectionOdds = nil
                        if tempTileConnectionOdds ~= nil and tempTileConnectionOdds[openingCoord] ~= nil then
                            connectionOdds = tempTileConnectionOdds[openingCoord]
                        elseif tileConnectionOdds[openingCoord] ~= nil then
                            connectionOdds = tileConnectionOdds[openingCoord]
                        end
                        if connectionOdds ~= nil then
                            --any occupied, incomplete features adjacent to this cloister should give a bonus score
                            local extendingFeatures = {}
                            for connectionStat, odds in pairs(connectionOdds) do
                                local features = string.split(connectionStat, "+")
                                for _, neighborFeatureNum in ipairs(features) do
                                    if neighborFeatureNum ~= "close" and neighborFeatureNum ~= "extend" and neighborFeatureNum ~= "blocked" and neighborFeatureNum ~= "totalValid" then
                                        if extendingFeatures[neighborFeatureNum] == nil then
                                            local feature = tempFeatureList[neighborFeatureNum]
                                            if feature == nil then feature = featureList[neighborFeatureNum] end
                                            if joinedActiveFigures[neighborFeatureNum] ~= nil and feature.nameOfFeature ~= 'Field' and feature.numOpenings ~= 0 and #joinedActiveFigures[neighborFeatureNum].followers > 0 then
                                                score = score + 0.3
                                                break
                                            end
                                            extendingFeatures[neighborFeatureNum] = true
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    if topWeight == -1 and getFeatureValue then
        return score
    end
    for player, value in pairs(followerCounts) do
        if (topWeight > 0 and value >= topWeight) then
            if scoreMultiplier == nil then
                featureScore[player] = featureScore[player] + score
            else
                featureScore[player] = featureScore[player] + (score * scoreMultiplier[player])
            end
        end
    end
    return featureScore
end

HAND_SCALE_CONSTANT = 1.3 -- for some reason, a hand with {1,1,1} scale is not 1 unit wide in each dimension, but instead around 1.2.
-- Move a card from the specified player's hand to the position smoothly
-- This works by first setting the position directly in front of the hand to prevent rubber-banding, then immediately moving to the intended position
function setPositionFromHandSmooth(obj, player_color, position)
  local handTransform = Player[player_color].getHandTransform()
  local tempPosition = obj.getPosition()
  tempPosition.x = tempPosition.x + (handTransform.scale.z * HAND_SCALE_CONSTANT / 2 + obj.getBoundsNormalized().size.z / 2) * handTransform.forward.x
  tempPosition.z = tempPosition.z + (handTransform.scale.z * HAND_SCALE_CONSTANT / 2 + obj.getBoundsNormalized().size.z / 2) * handTransform.forward.z
  obj.setRotation({obj.getRotation().x, handTransform.rotation.y, obj.getRotation().z})
  obj.setPosition(tempPosition)
  obj.setPositionSmooth(position)
end

--temporary function to get around the bug of not being able to setPosition from a hand
function dealInFrontOfHand(obj, player_color, is_a_deck)
  local handTransform = Player[player_color].getHandTransform()
  local tempPosition = handTransform.position
  tempPosition.y = tempPosition.y - 1
  tempPosition.x = tempPosition.x + (handTransform.scale.z + obj.getBoundsNormalized().size.z / 2) * handTransform.forward.x
  tempPosition.z = tempPosition.z + (handTransform.scale.z + obj.getBoundsNormalized().size.z / 2) * handTransform.forward.z
  if is_a_deck then
    local params = {}
    params.position = tempPosition
    params.rotation = {obj.getRotation().x + 180, handTransform.rotation.y, obj.getRotation().z}
    return obj.takeObject(params)
  else
    obj.setPositionSmooth(tempPosition)
    obj.setRotationSmooth({obj.getRotation().x + 180, handTransform.rotation.y, obj.getRotation().z})
  end
end

function AIMoveTileToLocation(newTile, xIndex, zIndex, tileRotation)
    if os.clock() - calculationStart < AI_DRAW_TILE_TIME then -- wait a minimum of this many seconds to make it flow nicer
        wait(AI_DRAW_TILE_TIME - (os.clock() - calculationStart))
    end

    addTile(xIndex, zIndex, newTile, tileRotation, false)

    if AI_ANIMATIONS_ENABLED then
        setPositionFromHandSmooth(newTile, activePlayers[currentPlayer], {xIndex * TILE_SPACING - MIDDLE_OFFSET.x, TABLE_SURFACE_Y, zIndex * TILE_SPACING - MIDDLE_OFFSET.z})
        newTile.setRotationSmooth({0, tileRotation * 90, 0})
    else
        newTile.setPosition({xIndex * TILE_SPACING - MIDDLE_OFFSET.x, TABLE_SURFACE_Y, zIndex * TILE_SPACING - MIDDLE_OFFSET.z})
        newTile.setRotation({0, tileRotation * 90, 0})
    end

    coroutine.yield(0) -- wait one frame before setting interactable to false due to a rubber-banding bug
    newTile.interactable = false

    if AI_ANIMATIONS_ENABLED then
        Timer.create({identifier=newTile.getGUID() .. os.clock(), function_name='AILockTile', function_owner=nil, parameters={tile=newTile}, delay=2.0})
    else
        AILockTile({tile=newTile})
    end
end

function AILockTile(params)
    local tile = params.tile
    tile.interactable = true
    if AUTOLOCK then
        tile.setLock(true)
    end
    return nextState('tile placed')
end

function AIMoveFigureToLocation()
    local featureNum = getFeatureNumAt(lastPlacedTileX, lastPlacedTileZ, highestScorePos)
    local nameOfFeature = featureList[featureNum].nameOfFeature
    local x, z = getFeatureLocation(lastPlacedTileX, lastPlacedTileZ, highestScorePos)
    for _, obj in ipairs(getObjectFromGUID(PLAY_AREA_SCRIPTING_ZONE_GUID).getObjects()) do
        if highestScoreFigure == obj.getVar('figureName') and obj.getVar('owner') == activePlayers[currentPlayer] then
            local xIndex, zIndex, _, _ = getFigureTileLocation(obj)
            if not tileGridOccupied(xIndex, zIndex) then
                local pieceRotation = 0
                if highestScorePos < 5 then pieceRotation = (highestScorePos - 1 + TILE_STANDARD_ROTATION) * 90
                elseif highestScorePos < 13 then pieceRotation = (math.floor((highestScorePos - 5) / 2) + TILE_STANDARD_ROTATION) * 90 end
                --NOTE: if pos > 12, rotation is arbitrary. This could be considered a flaw in the case of positions where there are rotating snap points since setPositionSmooth will ignore them. However, I don't think there's an easy way to solve it.
                pieceRotation = pieceRotation
                if table.contains(MEEPLE_TYPES, obj.getVar('figureName')) and nameOfFeature == 'Field' then
                    --lay the Follower down
                    if AI_ANIMATIONS_ENABLED then
                        obj.setRotationSmooth({90, pieceRotation, 0})
                    else
                        obj.setRotation({90, pieceRotation, 0})
                    end
                else
                    --align with the tile
                    if AI_ANIMATIONS_ENABLED then
                        obj.setRotationSmooth({0, pieceRotation, 0})
                    else
                        obj.setRotation({0, pieceRotation, 0})
                    end
                end
                obj.interactable = false
                if AI_ANIMATIONS_ENABLED then
                    obj.setPositionSmooth({(x * TILE_SPACING) + (lastPlacedTileX * TILE_SPACING) - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (lastPlacedTileZ * TILE_SPACING) - MIDDLE_OFFSET.z})
                    Timer.create({identifier=obj.getGUID() .. os.clock(), function_name='AILockFigure', function_owner=nil, parameters={figure=obj}, delay=2.0})
                else
                    obj.setPosition({(x * TILE_SPACING) + (lastPlacedTileX * TILE_SPACING) - MIDDLE_OFFSET.x, 1.5, (z * TILE_SPACING) + (lastPlacedTileZ * TILE_SPACING) - MIDDLE_OFFSET.z})
                    Timer.create({identifier=obj.getGUID() .. os.clock(), function_name='AILockFigure', function_owner=nil, parameters={figure=obj}, delay=0.5})
                end
                break
            end
        end
    end
end

function AILockFigure(params)
    local figure = params.figure
    figure.interactable = true
    if AUTOLOCK then
        figure.setLock(true)
    end
    if figure.getVar('figureName') == 'Shepherd' then
        shepherdAwaitingAction = figure.getGUID()
        return nextState('placed shepherd')
    else
        return nextState('placed figure')
    end
end

function AIChooseShepherdAction()
    if getPlayerOwner(activePlayers[currentPlayer]) == "AIEasy" then
        AICalculateBaselineScoresEasy()
    else
        AICalculateBaselineScores()
    end

    local shepherd = getObjectFromGUID(shepherdAwaitingAction)
    local xIndex, zIndex, xPosition, zPosition = getFigureTileLocation(shepherd)
    local closestPosition = findClosestPosition(xIndex, zIndex, xPosition, zPosition)
    local featureNum = getFeatureNumAt(xIndex, zIndex, closestPosition)
    if featureList[featureNum].numOpenings <= 1 then
        local params = {}
        params.shepherd = shepherd
        scoreFlock(params)
        return 1
    end

    local currentSheepScore = 0
    local currentPlayerHasShepherd = false
    --calculate how much the current field is worth. This will be used to calculate how much is at stake to be lost if a wolf is drawn
    for _, token in ipairs(activeNeutralFigures[featureNum].sheepTokens) do
        if token.getVar('tokenName') == 'Sheep' then
            currentSheepScore = currentSheepScore + token.getVar('count')
        -- elseif token.getVar('tokenName') == 'Wolf' then
        --     hasWolf = true
        end
    end

    --calculate the average value of the tokens left in the bag. The value of the wolf is calculated as the negative of the current value of the field
    local totalValue = 37 --total value of all sheep tokens combined
    totalValue = 37 - currentSheepScore - currentSheepScore --assuming there are 2 wolfs in the bag
    local numTokens = 18 --total number of sheep and wolf tokens
    for _, featureNeutralFigures in pairs(activeNeutralFigures) do
        for _, sheepToken in ipairs(featureNeutralFigures.sheepTokens) do
            if sheepToken.getVar('tokenName') == 'Sheep' then
                totalValue = totalValue - sheepToken.getVar('count')
            -- elseif sheepToken.getVar('tokenName') == 'Wolf' then
            --     totalValue = totalValue - currentSheepScore
            end
            numTokens = numTokens - 1
        end
    end
    newTokenValue = totalValue / numTokens

    --FIXME: Should also factor in the chance that the field will be no longer be extendable.
    --This is calculated differently than the block percentage, since we don't care if the field is ever "finished".
    --Since it would require more extensive calculation, I will leave it out for now, but it should be included later.
    -- local blockPercentage = featureBlockPercentages["" .. featureNum]
    -- local blockPenalty = STUCK_SHEPHERD_PENALTY * numRemainingMoves
    -- blockPenalty = blockPenalty * blockPercentage ^ BLOCK_PERCENTAGE_POWER_MODIFIER
    --
    -- newTokenValue = newTokenValue - blockPenalty

    if newTokenValue > SHEPHERD_DRAW_TOKEN_THRESHOLD then
        if controlPanelSettings['PnDDragon'] then
            addSheepToTile(shepherd)
        else
            addSheepToField(shepherd)
        end
    else
        local params = {}
        params.shepherd = shepherd
        scoreFlock(params)
    end
    return 1
end
